# @orkestrel/core

> Minimal, strongly-typed adapter/port toolkit for TypeScript. Compose capabilities with tokens, wire implementations via a tiny DI container, and drive lifecycles deterministically with an orchestrator.

This file contains all documentation content in a single document following the llmstxt.org standard.

## Orkestrel Core overview


Orkestrel Core is a minimal, strongly-typed toolkit for composing applications with ports and adapters in TypeScript. It gives you:

- Tokens and ports for decoupled contracts
- A tiny dependency injection container for wiring
- A deterministic Lifecycle to start/stop/destroy components
- An Orchestrator that drives many components in dependency order
- Small built-in adapters for registry, queue, emitter, events, layers, diagnostics, and logging

What it is not: a framework with hidden runtime magic. You assemble tokens and providers explicitly, keep providers synchronous, and move async work into lifecycle hooks.

Highlights
- Strong typing end-to-end with token contracts
- Synchronous provider model: factories/values must not be async (enforced)
- Deterministic lifecycle with hook timeouts and rollback on failures
- Topological start/stop/destroy with per-layer concurrency control
- Global helpers for multi-tenant scenarios: `container()` and `orchestrator()`

Key building blocks
- Tokens and ports: Create tokens with `createToken` or `createPortTokens`/`createPortToken` to model contracts.
- Providers: Register values, factories, or classes. Inject dependencies as a tuple `[A, B]` or object `{ a: A, b: B }`, or accept the `Container` directly. Providers must be synchronous.
- Lifecycle and Adapter: Extend `Lifecycle` or `Adapter` and override hooks (`onCreate`, `onStart`, `onStop`, `onDestroy`, `onTransition`).
- Container: Register tokens to providers, resolve single tokens or maps/tuples, create child scopes, and deterministically destroy owned lifecycles.
- Orchestrator: Register component providers with dependencies and optional timeouts, then `start`, `stop`, and `destroy` in dependency order with safe rollback.
- Built-in adapters: lightweight defaults for logger, diagnostics, event emitters, event bus, layers (topological grouping), queue (concurrency/timeouts), and registries (named instances).

Diagnostics and telemetry
- Failures carry stable codes like ORK1006 (missing provider), ORK1013/1014/1017 (phase aggregates), ORK1021/1022 (hook timeout/failure).
- You can observe lifecycle transitions, orchestrator phases, and component events via callbacks, tracer hooks, and diagnostics events.

Where to go next
- Start: install and a 5-minute tour
- Concepts: tokens, providers, lifecycle, and orchestration
- Core: built-in adapters and runtime pieces without API minutiae
- Examples: small, copy-pasteable snippets
- Tips: provider patterns, testing guidance, and common gotchas
- Tests: how to test components and orchestrations effectively
- FAQ: quick answers from simple to advanced scenarios

API reference is generated separately; see docs/api/index.md (Typedoc).

---

## Start


This page helps you install Orkestrel Core and build a working mental model in minutes.

Prerequisites
- Node.js 18 or newer
- TypeScript 5+ recommended

Install
```bat
npm install @orkestrel/core
```

Quick try: single-file app
- Save this as `quickstart.ts`:
```ts
import { Container, Orchestrator, Adapter, createToken, register } from '@orkestrel/core'

// A simple component with start/stop hooks
class Service extends Adapter {
  protected async onStart() { console.log('Service -> started') }
  protected async onStop() { console.log('Service -> stopped') }
}

// A typed contract and a value
const TNum = createToken<number>('num')
const TService = createToken<Service>('service')

// Wire things in a container and orchestrate
const container = new Container()
container.set(TNum, 41)

const app = new Orchestrator(container)
await app.start([
  register(TService, { useFactory: () => new Service() }),
])

console.log('Computed:', container.resolve(TNum) + 1)

await app.stop()
await app.destroy()
```
- Run it with Node + tsx:
```bat
npx tsx quickstart.ts
```

Hello tokens and container
```ts
import { Container, createToken } from '@orkestrel/core'

// 1) Define contracts as tokens
const A = createToken<number>('A')
const B = createToken<string>('B')
const OUT = createToken<{ a: number, b: string }>('OUT')

// 2) Register providers and resolve
const c = new Container()
c.set(A, 1)
c.set(B, 'two')
c.register(OUT, { useFactory: ({ a, b }) => ({ a, b }), inject: { a: A, b: B } })

const merged = c.resolve(OUT) // { a: 1, b: 'two' }
```

Lifecycle and Adapter
```ts
import { Adapter, createToken, Container } from '@orkestrel/core'

class Cache extends Adapter {
  private map = new Map<string, string>()
  protected async onStart() { this.map.set('ready', 'ok') }
  protected async onStop() { this.map.clear() }
}

const CacheTok = createToken<Cache>('Cache')
const c = new Container()
c.register(CacheTok, { useFactory: () => new Cache() })
const cache = c.resolve(CacheTok)
await cache.start()
await cache.stop()
await c.destroy() // ensures components are stopped/destroyed deterministically
```

Orchestrator quickstart
```ts
import { Orchestrator, Container, Adapter, createToken, register } from '@orkestrel/core'

class A extends Adapter {}
class B extends Adapter {}
const TA = createToken<A>('A')
const TB = createToken<B>('B')

const c = new Container()
const app = new Orchestrator(c)
await app.start([
  register(TA, { useFactory: () => new A() }),
  register(TB, { useFactory: () => new B() }, { dependencies: [TA] }),
])
await app.stop()
await app.destroy()
```

Ports: naming common contracts
```ts
import { createPortTokens, createPortToken, Container } from '@orkestrel/core'

// Bulk
const ports = createPortTokens({ logger: undefined as { info(msg: string): void } })
const c = new Container(); c.set(ports.logger, { info: console.log })
c.resolve(ports.logger).info('hello')

// Single
const HttpPort = createPortToken<{ get(url: string): Promise<string> }>('http')
```

Rules of the road
- Providers are synchronous: useValue must not be a Promise; useFactory must not be async and must not return a Promise. Move async work into lifecycle hooks (onStart/onStop/onDestroy).
- Inject dependencies via tuple `[A, B]` or object `{ a: A, b: B }`, or accept the `Container` directly.
- Prefer `Adapter` subclasses for long-lived components.

What next
- Concepts: deeper dive into tokens, providers, lifecycle, orchestrator
- Core: built-in adapters and runtime bits you can swap out
- Examples: more snippets and patterns
- Tips: provider patterns and gotchas
- Tests: how to test components and flows
- FAQ: quick answers from simple to advanced scenarios

---

## Concepts


This section explains the core ideas you’ll use day to day: tokens, providers, the container, lifecycle, and the orchestrator.

Tokens and ports
- Tokens are symbols that carry a type parameter. Create them via `createToken('desc')`.
- Ports are named groups of tokens. Create many with `createPortTokens({ ... })` or one with `createPortToken('name')`.
- Use tokens as keys to register and resolve implementations while keeping strong typing and loose coupling.

Providers and injection
- A provider can be one of:
  - Value: `{ useValue }`
  - Factory: `{ useFactory }` with optional inject
  - Class: `{ useClass }` with optional inject
- Injection styles:
  - Tuple: `inject: [A, B]` calls `useFactory(a, b)` or `new useClass(a, b)`
  - Object: `inject: { a: A, b: B }` calls `useFactory({ a, b })` or `new useClass({ a, b })`
  - Container: omit inject and accept the `Container` as first arg
  - No deps: omit inject and use a zero-arg factory/constructor
- Important: Providers are synchronous. Avoid async functions and promises in providers. Do async work inside lifecycle hooks.

Container
- Register then resolve:
  - `register(token, provider, lock?)` — set a provider for a token; optionally lock it against changes
  - `set(token, value, lock?)` — shorthand for value providers
  - `resolve(token | { map } | [tuple])` — strict; throws when a token is missing
  - `get(token | { map } | [tuple])` — optional; returns undefined for missing entries
- Scoping:
  - `createChild()` — inherit providers, override locally
  - `using(fn)` — run in a child scope, automatically destroyed afterwards
  - `using(apply, fn)` — configure the child scope via apply, then run fn
- Cleanup:
  - `destroy()` — stop/destroy owned lifecycle instances deterministically; aggregates errors if any

Lifecycle and Adapter
- `Lifecycle` is an abstract state machine with states: created → started → stopped → destroyed.
- Override hooks: `onCreate`, `onStart`, `onStop`, `onDestroy`, and the optional `onTransition(from, to, hook)`.
- Timeouts cap each hook; default is 5000ms. Set via constructor options.
- Events: `on('transition'|'create'|'start'|'stop'|'destroy'|'error', fn)`.
- `Adapter` extends `Lifecycle` and is a convenient base for components you register in the container.

Orchestrator
- Purpose: start, stop, destroy many components in a dependency-safe order.
- Register components via:
  - `orchestrator.register(token, provider, deps?, timeouts?)` for ad-hoc registration
  - `register(token, provider, options?)` to build typed entries for `orchestrator.start([...])`
- Dependencies:
  - Provide explicitly as `[A, B]` or `{ a: A, b: B }` on options
  - Or omit and let the orchestrator infer from tuple/object inject shapes
  - Cycles are detected and rejected
- Phases:
  - `start()` runs per-layer, topological order; rolls back by stopping already-started components on failure
  - `stop()` runs in reverse order; aggregates errors (ORK1014)
  - `destroy()` stops (if needed) then destroys; aggregates errors (ORK1017) and includes container cleanup
- Timeouts:
  - Per-orchestrator defaults via options, or per-registration overrides
  - Per-phase numbers or `{ onStart, onStop, onDestroy }`
- Telemetry:
  - `events` callbacks: onComponentStart/Stop/Destroy/Error
  - `tracer`: `onLayers` and `onPhase` for structured insights
  - Diagnostics emit event/trace/metric hooks and stable error codes

Global helpers
- `container()` returns the default container (or named ones via `container('name')`). It also exposes `set/clear/list/resolve/get/using` to work with the active container without threading it through your code.
- `orchestrator()` returns the default orchestrator (or named). Use `orchestrator.using(...)` to run work within its container scope.

Error codes at a glance
- ORK1006: container missing provider
- ORK1007: orchestrator duplicate registration
- ORK1008: orchestrator unknown dependency
- ORK1009: orchestrator cycle detected
- ORK1010/1011/1012: async provider inputs (value, async function, returned Promise)
- ORK1013/1014/1017: aggregated phase errors (start/stop/destroy)
- ORK1020/1021/1022: invalid lifecycle transition / hook timed out / hook failed

See also
- Start: a 5‑minute tour and installation
- Core: built-in adapters and runtime pieces
- Examples: copy‑pasteable snippets for common patterns
- Tips: provider patterns, composition, and troubleshooting
- Tests: setting up fast, deterministic tests
- FAQ: quick answers from simple to advanced scenarios

API reference is generated separately; see docs/api/index.md (Typedoc).

---

## Core


This page covers the runtime building blocks that ship with Orkestrel Core. It focuses on concepts and usage, not API signatures. Refer to the Typedoc in docs/api for the full API surface.

What’s included
- Logger: a minimal logging port and default adapters
- Diagnostics: structured errors and telemetry helpers
- Emitter: a tiny event emitter
- Event bus: async publish/subscribe with backpressure options
- Queue: run tasks with concurrency limits, deadlines, and per-task timeouts
- Layering: compute dependency layers and group tokens by layer
- Registry: named instance registry used for global container/orchestrator helpers

Logger
- LoggerPort: `log(level, message, fields?)` with levels `debug|info|warn|error`.
- Default adapters:
  - LoggerAdapter: logs to console (or any target you adapt)
  - NoopLogger: swallows logs; useful in tests
- You can pass your logger via options to Container, Orchestrator, Lifecycle, and adapters.

Example:
```ts
import { LoggerAdapter, NoopLogger, Container } from '@orkestrel/core'

const logger = new LoggerAdapter()
logger.log('info', 'App started', { version: '1.0.0' })

// Inject a custom logger into a container
const container = new Container({ logger: new NoopLogger() })
container.logger.log('debug', 'This will be discarded')
```

Diagnostics
- DiagnosticPort adds higher-level telemetry:
  - `error(err, context?)` — report an error with scope, code, token, phase, etc.
  - `fail(key, context?)` — throw an Error prefilled with a code (e.g., ORK1006) and optional help URL
  - `aggregate(key, details, context?)` — throw an aggregate Error with lifecycle detail entries
  - `help(key, context?)` — create an Error with code and helpUrl without throwing
  - `metric`, `trace`, `event` — send structured telemetry
- DiagnosticAdapter turns message keys like `ORK1013` into named, stable errors and emits telemetry through the configured Logger.
- Codes used across core include:
  - Container: ORK1005, ORK1006, ORK1016
  - Orchestrator: ORK1007–ORK1015 (duplicates, unknown deps, cycles, async provider guards, phase aggregates)
  - Lifecycle: ORK1020–ORK1022 (invalid transitions, hook timeout/failure)
  - Ports/Queue/Internal: ORK1040/ORK1050–ORK1053/ORK1099

Emitter
- A tiny type-safe emitter with `on`, `off`, `emit`, and `removeAllListeners`.
- Used by Lifecycle to emit `transition`, `create`, `start`, `stop`, `destroy`, and `error`.

Event bus
- A simple pub/sub interface (`publish`, `subscribe`, `topics`) with options:
  - sequential delivery vs best-effort parallel
  - error handling callback
- Great for component-level messages that are not strict dependencies.

Example:
```ts
import { EventAdapter } from '@orkestrel/core'

type Events = { 'user:created': { id: string, name: string } }
const bus = new EventAdapter<Events>({ sequential: true })

const unsubscribe = await bus.subscribe('user:created', async (u) => {
  console.log('Created:', u.id, u.name)
})

await bus.publish('user:created', { id: 'u1', name: 'Alice' })
await unsubscribe()
```

Queue
- Run an array of tasks with options: `concurrency`, `timeout`, `deadline`, and `signal`.
- The default QueueAdapter is used by Lifecycle to enforce one-at-a-time hooks with a shared deadline.
- In the orchestrator, you can inject a queue to cap per-layer parallelism.

Layering
- Given nodes `{ token, dependencies }`, compute layers such that dependencies appear in earlier layers.
- The orchestrator uses this to determine safe start/stop/destroy order.

Registry
- A named-instance registry with `get`, `resolve`, `set`, `clear`, and `list`.
- The global helpers `container()` and `orchestrator()` are built on registries to support named instances.

Practical tips
- Pass a `NoopLogger` and rely on codes in tests to keep output clean while asserting behaviors.
- Consider injecting your own queue into Orchestrator to cap start/stop/destroy parallelism for IO-heavy components.
- Use the `events` callbacks for user-facing notifications and the `tracer` for structured capture of layers and outcomes.
- Keep adapter implementations small and focused; only override the Lifecycle hooks you actually need.

See also
- Overview: mental model and navigation
- Start: installation and a 5‑minute tour
- Concepts: tokens, providers, lifecycle, orchestrator
- Examples: copy‑pasteable snippets for common patterns
- Tips: provider patterns, composition, and troubleshooting
- Tests: fast, deterministic testing guidance
- FAQ: quick answers from simple to advanced scenarios

API reference is generated separately; see docs/api/index.md (Typedoc).

---

## Ecosystem


Orkestrel Core focuses on small, composable primitives instead of a big framework. It’s designed to slot into your stack with minimal friction.

Where it fits
- Libraries and services that need explicit startup/shutdown with timeouts
- Apps that value compile-time contracts (tokens and ports) and clear wiring
- Multi-tenant or plugin-style apps that benefit from scoped containers

Interoperability
- Logging: implement `LoggerPort` to bridge to your logger (Winston/Pino/console) and pass it to Container/Orchestrator/Lifecycle.
- Metrics/Tracing: implement a `DiagnosticPort` or adapt the default `DiagnosticAdapter` to forward metrics/traces/events to your observability backend.
- Eventing: the event emitter and event bus ports are intentionally tiny; you can wrap other bus clients behind the same port shape.
- Tasking: plug in a custom `QueuePort` to drive hooks and orchestrator phases with your preferred scheduler.

Typical integrations
- Web servers: model servers as `Adapter` subclasses; register them in the container and start via the orchestrator. Use timeouts to guarantee bounded shutdown.
- Workers/daemons: group independent workers into layers and cap per-layer concurrency via a queue.
- Modular apps: publish shared contracts as port tokens and swap implementations per environment or tenant.

Out of scope
- HTTP routing, database clients, and other domain-specific features are intentionally out of Orkestrel Core. Treat those as adapters you wire in.

Versioning and stability
- Error codes and core semantics are intended to be stable within a major version. See the changelog and Typedoc for details.

If you publish community adapters or examples, consider using token-friendly shapes so others can adopt them without coupling to runtime details.

See also
- Overview: mental model and navigation
- Start: installation and a 5‑minute tour
- Concepts: tokens, providers, lifecycle, orchestrator
- Core: built-in adapters and runtime pieces
- Examples: copy‑pasteable snippets for common patterns
- Tips: provider patterns, composition, and troubleshooting
- Tests: fast, deterministic testing guidance
- FAQ: quick answers from simple to advanced scenarios

API reference is generated separately; see docs/api/index.md (Typedoc).

---

## Examples


Container: resolve a map and a tuple
```ts
import { Container, createToken } from '@orkestrel/core'

const A = createToken<number>('A')
const B = createToken<string>('B')
const C = createToken<boolean>('C')

const c = new Container()
c.set(A, 1)
c.set(B, 'two')
c.set(C, true)

// map
const { a, b, c: cval } = c.resolve({ a: A, b: B, c: C })
// tuple
const [aa, bb] = c.resolve([A, B] as const)
```

Container: scoped overrides with using
```ts
const A = createToken<number>('A')
const root = new Container()
root.set(A, 7)

const out = await root.using(async (scope) => {
  scope.set(A, 41)
  return scope.resolve(A) + 1
})
// out === 43
// after using(), the child scope is destroyed and root remains unchanged
```

Lifecycle: simple adapter
```ts
import { Adapter, createToken, Container } from '@orkestrel/core'

class Cache extends Adapter {
  ready = false
  protected async onStart() { this.ready = true }
  protected async onStop() { this.ready = false }
}

const CacheTok = createToken<Cache>('Cache')
const c = new Container()
c.register(CacheTok, { useFactory: () => new Cache() })
const cache = c.resolve(CacheTok)
await cache.start()
await cache.stop()
await c.destroy()
```

Orchestrator: register helper and start order
```ts
import { Orchestrator, Container, Adapter, createToken, register } from '@orkestrel/core'

class A extends Adapter {}
class B extends Adapter {}
const TA = createToken<A>('A')
const TB = createToken<B>('B')

const app = new Orchestrator(new Container())
await app.start([
  register(TA, { useFactory: () => new A() }),
  register(TB, { useFactory: () => new B() }, { dependencies: [TA] }),
])
await app.destroy()
```

Orchestrator: infer dependencies from inject
```ts
class NeedsPorts extends Adapter { constructor(public a: A, public b: B) { super() } }
const TA = createToken<A>('A')
const TB = createToken<B>('B')
const TNeeds = createToken<NeedsPorts>('Needs')
const app = new Orchestrator(new Container())
await app.start([
  register(TA, { useFactory: () => new A() }),
  register(TB, { useFactory: () => new B() }),
  // dependencies omitted; inferred from tuple inject
  register(TNeeds, { useClass: NeedsPorts, inject: [TA, TB] }),
])
await app.destroy()
```

Orchestrator: per-registration timeouts
```ts
class SlowStart extends Adapter { constructor(private ms: number) { super() } protected async onStart() { await new Promise(r => setTimeout(r, this.ms)) } }
const SLOW = createToken<SlowStart>('SLOW')
const app = new Orchestrator(new Container())
await app.start([
  register(SLOW, { useFactory: () => new SlowStart(100) }, { timeouts: { onStart: 10 } }),
]).catch(() => {/* aggregated error ORK1013 */})
```

Orchestrator: tracer hooks
```js
import { Orchestrator, Container } from '@orkestrel/core'

const phases = []
const app = new Orchestrator(new Container(), {
  tracer: {
    onLayers: ({ layers }) => console.log('layers', layers),
    onPhase: (p) => phases.push({
      phase: p.phase,
      layer: p.layer,
      outcomes: p.outcomes.map(o => ({ token: o.token, ok: o.ok })),
    }),
  },
})
// ... register and start
```

Ports: bulk and single tokens
```ts
import { createPortTokens, createPortToken, Container } from '@orkestrel/core'

const ports = createPortTokens({ logger: undefined as { info(msg: string): void } })
const c = new Container()
c.set(ports.logger, { info: console.log })
c.resolve(ports.logger).info('hi')

const Http = createPortToken<{ get(url: string): Promise<string> }>('http')
```

Global helpers
```ts
import { container, orchestrator, createToken } from '@orkestrel/core'

// containers
const A = createToken<number>('A')
container().set(A, 7)
const v = container.resolve(A) // 7
await container.using(async (scope) => { scope.set(A, 1) })

// orchestrators
const app = orchestrator()
await app.container.using(scope => {/* register */})
```

See also
- Overview and Start for the mental model and installation
- Concepts for tokens/providers/lifecycle/orchestration
- Core for built-in adapters
- Tips for patterns and troubleshooting
- Tests for fast, deterministic testing guidance
- FAQ for quick answers from simple to advanced scenarios

API reference is generated separately; see docs/api/index.md (Typedoc).

---

## Tips


A practical grab bag: provider patterns, lifetimes, typing conventions, composition patterns, and troubleshooting. For quick answers, see the standalone FAQ.

Provider shapes and injection

- Value: `{ useValue }` — external ownership; container won’t destroy it automatically.
- Factory: `{ useFactory }` — lazy singleton; container owns disposal for Lifecycle instances.
- Class: `{ useClass }` — lazy singleton; container owns disposal for Lifecycle instances.
- Injection styles:
  - Tuple: `inject: [A, B]` → `(a, b)` or `new C(a, b)`
  - Object: `inject: { a: A, b: B }` → `({ a, b })` or `new C({ a, b })`
  - Container: no inject; factory/ctor receives `Container` as first parameter when applicable
  - No deps: zero-arg factory/ctor
- Synchronous only: `useValue` must not be a Promise; `useFactory` must not be async and must not return a Promise. Move IO to lifecycle hooks.

Lifetimes and ownership

- Singleton by design per container; first resolve materializes and caches.
- Scope per request/job with `createChild()` or `using(...)`, then `await scope.destroy()`.
- `Container.destroy()`: stops started lifecycles and destroys owned lifecycles from factory/class providers; value-provided lifecycles are considered externally owned.
- Many instances: use a Manager (an Adapter) that owns children internally and exposes a single lifecycle to the orchestrator.

Typing guidelines

- Create tokens via `createToken<T>(desc)` or groups via `createPortTokens(shape)` and extend with `extendPorts(base, ext)` (duplicate keys are rejected).
- Prefer explicit types and `readonly` public shapes. Avoid `any` and non-null assertions.
- Narrow using guards like `isFactoryProviderWithTuple/Object`, `isClassProviderWithTuple/Object`, `isToken`, and `isProviderObject` rather than casting.
- Treat token maps as configuration; they’re frozen read-only objects.

Composition patterns

- Startup with register helper:

  ```ts
  await app.start([
    register(TLogger, { useFactory: () => new Logger() }),
    register(TEmail, { useFactory: () => new Email() }, { dependencies: [TLogger] }),
  ])
  ```

- Explicit dependencies control lifecycle ordering; inject controls constructor/factory arguments. Use both when needed.
- Use orchestrator defaults for timeouts; override per component when necessary.
- Lock critical providers with `register(token, provider, true)` or `set(token, value, true)` to prevent accidental overrides.
- Use `container.using(apply, fn)` to stage scoped overrides then run work; the scope auto-destroys.

Tracing and events

- Orchestrator `events` are convenient for logs and metrics; `tracer` gives structured insight into layers and phase outcomes.
- Lifecycle `on('transition'|'start'|'stop'|'destroy'|'error')` lets you observe state changes; filter in `onTransition` when you only care about some hooks.

Troubleshooting (stable error codes)

- ORK1006 Missing provider: ensure the token was registered or use `get` instead of `resolve` when optional.
- ORK1007 Duplicate registration: don’t register the same token twice in one orchestrator.
- ORK1008 Unknown dependency: declare all dependencies and register them before start.
- ORK1009 Cycle detected: break cycles by splitting responsibilities or inverting a call.
- ORK1010/1011/1012 Async provider guards: keep providers sync; move async to lifecycle hooks or pre-resolve values.
- ORK1013/1014/1017 Aggregated start/stop/destroy errors: catch and inspect `.details` (array of per-component failures).
- ORK1020 Invalid lifecycle transition: respect created → started → stopped → destroyed.
- ORK1021 Hook timed out: reduce hook work or increase timeouts.
- ORK1022 Hook failed: handle errors in hooks; they’ll be wrapped and propagated.
- ORK1040 Duplicate port key in `extendPorts`: rename or split the shape.

Testing tips

- Keep hook timeouts small (10–50ms) for fast feedback.
- Avoid mocks in core; use real adapters and assert observable behavior.
- Use `container.using` for scoped tests and ensure cleanup.
- For aggregated errors, use `isAggregateLifecycleError` and assert on `.details`.

Quick references

- Container: `register`, `set`, `resolve`, `get`, `createChild`, `using`, `destroy`
- Lifecycle: override hooks; observe with `on`/`off`; default hook timeout 5000ms
- Orchestrator: `register`, `start`, `stop`, `destroy`; dependencies and per-phase timeouts; `events` and `tracer`
- Ports: `createPortTokens`, `createPortToken`, `extendPorts`

See also
- Overview and Start for the mental model and installation
- Concepts for tokens/providers/lifecycle/orchestration
- Core for built-in adapters
- Examples for copy‑pasteable patterns
- Tests for fast, deterministic testing guidance
- FAQ for quick answers from simple to advanced scenarios

API reference is generated separately; see docs/api/index.md (Typedoc).

---

## Tests


Guidelines to keep tests fast, deterministic, and representative of real-world usage without adding heavy tooling.

Principles
- Prefer tiny, isolated scenarios that map directly to source behaviors.
- Avoid mocks/fakes/spies in this core repo. Use real components and built-ins only. Consumers can use fakes/spies when testing their apps.
- Keep timeouts small to make tests snappy and still representative. Favor deterministic assertions.

Patterns

Scoping with Container.using
Run code within a child scope and ensure cleanup after execution.
```ts
import { Container } from '@orkestrel/core'

const root = new Container()
const result = await root.using(async (scope) => {
  // register overrides in the scoped container if needed
  // use scope.resolve(...) inside the scope
  return 42
})
// scope is destroyed here
```

Apply overrides via an apply callback before running work:
```ts
import { Container, createToken } from '@orkestrel/core'

const T = createToken<string>('test:val')
const root = new Container()
const out = await root.using(
  (scope) => {
    scope.register(T, { useValue: 'scoped' })
  },
  async (scope) => {
    return scope.resolve(T)
  },
)
// out === 'scoped'; scope was destroyed after the function
```

Lifecycle expectations
Assert transitions and errors using real Lifecycle-derived classes.
```ts
import { Lifecycle } from '@orkestrel/core'
import { strict as assert } from 'node:assert'

class Svc extends Lifecycle {
  protected async onStart() { /* lightweight */ }
  protected async onStop() { /* lightweight */ }
}

const s = new Svc({ timeouts: 50 })
await s.start()
assert.equal(s.state, 'started')
await s.stop()
assert.equal(s.state, 'stopped')
```

Orchestrator flows
Use the Orchestrator to exercise start/stop/destroy ordering with small graphs.
```ts
import { Orchestrator, Container, register, createToken, Lifecycle } from '@orkestrel/core'

interface Port { n(): number }
const T = createToken<Port>('test:port')

class Impl extends Lifecycle implements Port {
  n() { return 1 }
}

const app = new Orchestrator(new Container())
app.register(T, { useFactory: () => new Impl() })
await app.start()
await app.stop()
await app.destroy()
```

Deterministic timeouts
- Keep hook and orchestrator timeouts low (e.g., 10–50ms) in tests.
- Avoid external timer-mocking libraries; structure code to be deterministic with short timers.

Aggregated errors
Catch AggregateLifecycleError when testing error paths and inspect details for per-component context.
```ts
import { isAggregateLifecycleError } from '@orkestrel/core'

try {
  await app.stop()
} catch (e) {
  if (isAggregateLifecycleError(e)) {
    for (const d of e.details) {
      console.error(`${d.tokenDescription} failed during ${d.phase}${d.timedOut ? ' (timed out)' : ''} after ${d.durationMs}ms:`, d.error.message)
    }
  } else {
    throw e
  }
}
```

Policy for the core repo
- No mocks, fakes, or spies in tests here; use only built-ins and actual code paths.
- Keep tests short and focused. Add happy-path + 1–2 edge cases for public behavior.
- Aim for fast runs (seconds, not minutes) with tsx --test and tsc --noEmit.

See also
- Overview and Start for the mental model and installation
- Concepts for tokens/providers/lifecycle/orchestration
- Core for built-in adapters
- Examples for copy‑pasteable scenarios
- Tips for composition patterns and troubleshooting
- FAQ for quick answers from simple to advanced scenarios

API reference is generated separately; see docs/api/index.md (Typedoc).

---

## Contribute


A compact guide so humans and coding agents can ship high‑quality changes to @orkestrel/core with confidence.

## Principles (what we optimize for)
- Determinism: same inputs, same outputs; preserve insertion and declared dependency order
- Strong typing: strict types with zero `any`, no non‑null assertions, and honest boundaries
- Small surface: minimal, composable APIs; real use cases drive growth
- Portability: browser + Node compatible by default; in‑memory adapters in core
- Predictable lifecycles: sync providers, async work in lifecycle hooks with timeouts

## Quick workflow (how to work)
1) Edit source in `src/`
2) Mirror tests in `tests/` (one test file per source file)
3) Run locally:
    - `npm run check` — typecheck everything
    - `npm test` — run unit tests
    - `npm run format` — lint + autofix
    - `npm run build` — build types and ESM
    - `npm run docs` — generate API reference to `docs/api/`

Node/browser targets
- TypeScript‑first, ESM‑only (`"type": "module"`), moduleResolution: bundler
- No Node‑only primitives in core adapters or public APIs

## Typing ethos (strict, helpful, honest)
- No `any`. No non‑null assertions (`!`). Avoid unsafe casts; prefer narrowing
- Validate at the edges: accept `unknown` from the outside world, check, then type
- Prefer `readonly` for public outputs; avoid mutating returned values
- Keep helpers small and well‑typed; document invariants where helpful
- Use provided guards from `src/helpers.ts` to narrow unions incrementally

If you must widen or coerce, write a guard instead and cover it with tests.

## TSDoc policy (what to document)
- Public exported classes and their public methods: full TSDoc
    - Include: description, `@param` and `@returns` with descriptions, an `@example`, and `@remarks` if helpful
    - Examples must use fenced code blocks with the `ts` language tag (```ts) — be consistent across the codebase
- Exported functions: full TSDoc as above
- Simple getters and setters: do not include an `@example`. Provide a concise description and a meaningful `@returns` description.
- Private methods, non‑exported classes/functions, and overload signatures: use a single‑line description comment only (no full TSDoc block)
- Types and interfaces: no TSDoc — remove banner/header or note comments on types/interfaces
- Remove header‑only banners and note style comments

Documenting options objects (important)
- TSDoc does not support dotted `@param` names (e.g., `@param opts.foo`). Using them triggers `tsdoc-param-tag-with-invalid-name`.
- For options objects, document a single parameter for the object, and list its properties in the description (or under `@remarks`).
- Do not include type annotations in JSDoc; rely on TypeScript types.

Example pattern
```
/**
 * Construct a Thing.
 *
 * @param opts - Configuration options:
 * - parent: Optional parent container to inherit providers from
 * - logger: Optional logger port for diagnostics
 * - diagnostic: Optional diagnostic port for error reporting
 */
constructor(opts: ThingOptions = {}) { /* ... */ }
```

Consistency
- Examples should be minimal, copy‑paste friendly, and reflect real usage
- Prefer `readonly` in public shapes and return immutable views when sensible
- Use existing diagnostic codes and helpers; don’t invent new ones casually

## API and change control
- Do not expand the public API without a concrete, multi‑site use case
- Prefer tiny extensions to existing shapes over new abstractions
- Keep ports stable; evolve via narrowly scoped, additive methods with rationale

## Providers and lifecycle (core constraints)
- Providers are synchronous only
    - `useValue`: must not be a Promise (sync only)
    - `useFactory`: must not be `async` and must not return a Promise
- Move async work to `Lifecycle` hooks (`onStart`, `onStop`, `onDestroy`) with per‑phase timeouts
- On start failure, rollback deterministically (stop previously started components in reverse order)

Diagnostics (selected)
- Unknown dependency → ORK1008
- Cycle detected → ORK1009
- Async provider guards → ORK1010/ORK1011/ORK1012
- Aggregates on start/stop/destroy → ORK1013/ORK1014/ORK1017
- Invalid transition / Hook timeout → ORK1020 / ORK1021

## Ports + adapters
- Contracts: minimal, explicit, generic where useful; browser + Node friendly
- Adapters: in‑memory, side‑effect free on import; deterministic order
- Composition over inheritance; keep heavy logic in private helpers
- Caching: invalidate deterministically on mutation
- Use core diagnostics and isolate listener errors via `safeInvoke`

Determinism
- Respect insertion order for initial frontiers/queues; respect declared input order
- If tie‑breaking is required, make it stable and document it

## Testing conventions and QA
- Tests mirror source files: `tests/[file].test.ts`
- Use real in‑memory adapters; no mocks/fakes/spies in core tests
- Cover: success/failure/timeout, concurrency caps, ordering/determinism, aggregation
- No CI workflows in this repo — enforce the same gates locally before pushing or publishing: typecheck clean, lint clean, tests green, docs build

## Naming and tokens
- Ports live behind tokens; use `tokenDescription` for diagnostics/tracing payloads
- Prefer `createPortToken` / `createPortTokens` and `extendPorts` for stable, typed maps

## Guidance for automated agents
- Keep determinism; document any tie‑breaking
- Follow the TSDoc policy above strictly (including ```ts examples and no type/interface TSDoc)
- Omit `@example` for simple getters/setters; include only description and `@returns` unless a remark is essential
- Do not add new public APIs without a compelling multi‑site need
- Providers stay synchronous; move async into lifecycle hooks
- Ports minimal, adapters in‑memory; avoid Node‑only APIs in core
- Strict types: no `any`, no non‑null assertions; prefer `readonly` results
- Update tests alongside code; add new cases to the existing file
- Use the quick workflow commands before proposing changes
- Do not add GitHub Workflows or external CI; stick to local gates and existing npm scripts

## Documentation
- API reference is generated by TypeDoc to `docs/api/` via `npm run docs`
- TypeDoc landing page: `docs/api/index.md` (generated)

## Code of Conduct
Be kind. Assume good intent. Discuss ideas, not people.

See also
- Overview and Start for the project mental model and installation
- Concepts for tokens/providers/lifecycle/orchestration
- Core for built‑in adapters and runtime pieces
- Examples and Tests for practical usage and verification patterns
- Tips for composition patterns and troubleshooting
- FAQ for quick answers from simple to advanced scenarios

API reference is generated separately; see docs/api/index.md (Typedoc).

---

## FAQ


This FAQ grows in complexity from basic concepts to advanced usage. It complements the guide and keeps API details out of the way. For signatures and full types, see the generated API reference in docs/api/.

Basics

- What is a token?
  - A token is a typed handle (created with createToken or createPortToken/s) you use as a key to register and resolve implementations. It carries only type information and a human description for diagnostics.
  - Example:
    ```ts
    import { Container, createToken } from '@orkestrel/core'
    const T = createToken<number>('answer')
    const c = new Container()
    c.set(T, 42)
    console.log(c.resolve(T)) // 42
    ```

- Value vs factory vs class providers?
  - Value: useValue registers an already-created value. The container does not own its lifecycle.
  - Factory: useFactory constructs the value lazily on first resolve. If it returns a Lifecycle instance, the container owns its stop/destroy.
  - Class: useClass constructs via new on first resolve; ownership mirrors factory.
  - Example:
    ```ts
    import { Container, createToken } from '@orkestrel/core'
    class Svc { n = 1 }
    const TV = createToken<Svc>('svc:value')
    const TF = createToken<Svc>('svc:factory')
    const TC = createToken<Svc>('svc:class')
    const c = new Container()
    c.register(TV, { useValue: new Svc() })
    c.register(TF, { useFactory: () => new Svc() })
    c.register(TC, { useClass: Svc })
    console.log(c.resolve(TF).n + c.resolve(TC).n + c.resolve(TV).n) // 3
    ```

- Can providers be async?
  - No. Providers must be synchronous. Do async work in Lifecycle hooks (onStart/onStop/onDestroy). Violations are guarded with stable error codes (e.g., ORK1010/1011/1012).

- How do I inject dependencies?
  - Tuple: inject: [A, B] calls factory/constructor as (a, b).
  - Object: inject: { a: A, b: B } calls factory/constructor as ({ a, b }).
  - Container: omit inject and accept the Container as the first argument when applicable.
  - Example:
    ```ts
    import { Container, createToken } from '@orkestrel/core'
    const A = createToken<number>('A'), B = createToken<string>('B'), OUT = createToken<string>('OUT')
    const c = new Container(); c.set(A, 2); c.set(B, 'x')
    c.register(OUT, { useFactory: (a, b) => b + a, inject: [A, B] })
    console.log(c.resolve(OUT)) // 'x2'
    ```

- What happens on missing tokens?
  - resolve throws with ORK1006 (missing provider). Use get if a dependency is optional.
  - Example:
    ```ts
    import { Container, createToken } from '@orkestrel/core'
    const Maybe = createToken<number>('maybe')
    const c = new Container()
    console.log(c.get(Maybe)) // undefined
    // c.resolve(Maybe) // would throw ORK1006
    ```

Intermediate

- How does scoping work?
  - Create a child with createChild() or use using(...) to run work in a short-lived scope. Child containers inherit providers and can override them; when the scope ends, owned lifecycles are deterministically destroyed.
  - Example:
    ```ts
    import { Container, createToken } from '@orkestrel/core'
    const T = createToken<number>('T')
    const root = new Container(); root.set(T, 1)
    const out = await root.using(async (scope) => { scope.set(T, 41); return scope.resolve(T) + 1 })
    console.log(out, root.resolve(T)) // 42 1
    ```

- When should I extend Adapter vs raw Lifecycle?
  - Prefer Adapter for components you intend to register in a container and potentially orchestrate. Use Lifecycle directly for custom state machines or when you do not need adapter conveniences.
  - Example:
    ```ts
    import { Adapter, Container, createToken } from '@orkestrel/core'
    class Cache extends Adapter { ready = false; protected async onStart(){ this.ready = true } protected async onStop(){ this.ready = false } }
    const TCache = createToken<Cache>('cache'); const c = new Container(); c.register(TCache, { useFactory: () => new Cache() })
    const cache = c.resolve(TCache); await cache.start(); console.log(cache.ready); await cache.stop(); await c.destroy()
    ```

- How are orchestrator dependencies determined?
  - Explicit: declare dependencies in the register(...) options. Inferred: when using tuple/object inject, dependencies can be inferred from tokens. Cycles are rejected with ORK1009.
  - Example:
    ```ts
    import { Orchestrator, Container, Adapter, createToken, register } from '@orkestrel/core'
    class A extends Adapter {} class B extends Adapter {}
    const TA = createToken<A>('A'), TB = createToken<B>('B')
    const app = new Orchestrator(new Container())
    await app.start([
      register(TA, { useFactory: () => new A() }),
      register(TB, { useFactory: () => new B() }, { dependencies: [TA] }),
    ])
    await app.destroy()
    ```

- What if a component fails to start?
  - The orchestrator rolls back: components already started are stopped in reverse dependency order. Failures are aggregated and reported with details.
  - Example idea: set a very small onStart timeout for a slow component and catch the aggregate. See Examples: “per-registration timeouts.”

- How do timeouts work?
  - Each hook has a timeout (default 5000ms). Configure globally on Lifecycle/Orchestrator or per registration with numbers or per-phase overrides: { onStart, onStop, onDestroy }.
  - Example:
    ```ts
    import { Orchestrator, Container, Adapter, createToken, register } from '@orkestrel/core'
    class Slow extends Adapter { constructor(private ms:number){ super() } protected async onStart(){ await new Promise(r=>setTimeout(r,this.ms)) } }
    const TSlow = createToken<Slow>('Slow'); const app = new Orchestrator(new Container())
    try {
      await app.start([ register(TSlow, { useFactory: () => new Slow(50) }, { timeouts: { onStart: 10 } }) ])
    } catch (e) { console.log('start aggregated error'); }
    await app.destroy()
    ```

Advanced

- Multi-tenant or per-request work?
  - Use container.createChild() or container.using() to produce an isolated scope per tenant/request/job. Register overrides within the child, do work, then destroy.

- Global helpers container() and orchestrator()
  - Access a default or named instance without threading references. Use container().using(...) or orchestrator().start([...]) where convenient. Treat these as conveniences over explicit wiring.
  - Example:
    ```ts
    import { container, orchestrator, createToken, Adapter, register } from '@orkestrel/core'
    const TNum = createToken<number>('num'); container().set(TNum, 7)
    console.log(container.resolve(TNum))
    class Svc extends Adapter {}
    const TS = createToken<Svc>('svc')
    const app = orchestrator(); await app.start([ register(TS, { useFactory: () => new Svc() }) ]); await app.destroy()
    ```

- Observability options
  - Diagnostics provide stable error codes and helpers (error, fail, aggregate). Orchestrator exposes events and tracer hooks for layers and phase outcomes. You can swap or adapt logger/diagnostic/queue ports to your stack.

- Controlling concurrency
  - Inject a QueuePort into the orchestrator to cap per-layer parallelism during start/stop/destroy. Use deadlines and per-task timeouts for bounded shutdown.

- Value providers that are lifecycles
  - The container treats useValue as externally owned. If you pass a Lifecycle instance via useValue, you are responsible for stopping/destroying it; prefer factory/class providers so the container owns disposal.

Troubleshooting (by symptom)

- I get a missing provider error
  - Check token registration and resolution scope. Use get for optional dependencies. Code: ORK1006.

- Something times out during start/stop/destroy
  - Reduce work within hooks, increase timeouts sparingly, or adjust orchestrator queue concurrency. Codes: ORK1021 (hook timeout) and aggregated ORK1013/1014/1017.

- Duplicate registration in orchestrator
  - Ensure each token is registered once per start() call. Code: ORK1007.

- Unknown dependency or cycle detected
  - Declare all dependencies; break cycles by splitting responsibilities or inverting calls. Codes: ORK1008 (unknown), ORK1009 (cycle).

- Async providers rejected
  - Keep providers sync; move IO to lifecycle hooks or pre-resolve values. Codes: ORK1010/1011/1012.

Recipes

- Scoped override for a test or job
  - container.using(apply, fn) lets you stage overrides then run work in a child; the scope auto-destroys afterward.

- Per-component timeouts
  - Provide timeouts on a registration: { timeouts: { onStart: 50, onStop: 50 } } to bound slow components.

- Observing transitions
  - Lifecycle emits transition events; attach listeners for create/start/stop/destroy/error to integrate with logs/metrics.

Pointers

- Start here: Overview and Start pages for the mental model and a five-minute tour.
- Deep dive: Concepts for tokens/providers/lifecycle/orchestration; Core for built-in adapters.
- Copy-paste: Examples for common patterns; Tips for composition and troubleshooting.
- API details live in docs/api/ (generated by TypeDoc).

---

## Abstract Class: Adapter

[**@orkestrel/core**](../index.md)

***

# Abstract Class: Adapter

Defined in: [adapter.ts:40](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapter.ts#L40)

Base class for building adapters/components that participate in a deterministic lifecycle.

Extends [Lifecycle](Lifecycle.md) and exposes the same hook surface (override the protected onX methods).
You typically subclass Adapter, implement the hooks you need, and then register an instance with
a [Container](Container.md) or [Orchestrator](Orchestrator.md).

## Example

```ts
import { Adapter, createToken, Container } from '@orkestrel/core'

// Define a component by subclassing Adapter and overriding hooks
class HttpServer extends Adapter {
  private server?: { listen: () => Promise<void>, close: () => Promise<void> }
  constructor(private readonly port: number) { super() }
  protected async onStart() {
    // create server; await server.listen()
    this.server = undefined
  }
  protected async onStop() {
    // await this.server?.close()
  }
}

// Register and drive it via the container
const TOK = createToken<HttpServer>('http')
const container = new Container()
container.register(TOK, { useFactory: () => new HttpServer(3000) })
const srv = container.resolve(TOK)
await srv.start()
await srv.stop()
await container.destroy() // ensures srv is destroyed
```

## Remarks

Override any of the protected hooks: onCreate, onStart, onStop, onDestroy, onTransition.

## Extends

- [`Lifecycle`](Lifecycle.md)

## Constructors

### Constructor

> **new Adapter**(`opts`): `Adapter`

Defined in: [lifecycle.ts:65](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L65)

Construct a Lifecycle with optional configuration for timeouts, emitters, queue, logger, and diagnostic ports.

#### Parameters

##### opts

[`LifecycleOptions`](../interfaces/LifecycleOptions.md) = `{}`

Configuration options:
- timeouts: Timeout in milliseconds for each lifecycle hook (default: 5000)
- emitInitial: Whether to emit the current state immediately on first transition listener (default: true)
- emitter: Optional custom emitter port
- queue: Optional custom queue port for serializing hooks
- logger: Optional logger port
- diagnostic: Optional diagnostic port for telemetry and errors

#### Returns

`Adapter`

#### Inherited from

[`Lifecycle`](Lifecycle.md).[`constructor`](Lifecycle.md#constructor)

## Accessors

### diagnostics

#### Get Signature

> **get** **diagnostics**(): [`DiagnosticPort`](../interfaces/DiagnosticPort.md)

Defined in: [lifecycle.ts:105](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L105)

Access the diagnostic port used for telemetry and error reporting.

##### Returns

[`DiagnosticPort`](../interfaces/DiagnosticPort.md)

The DiagnosticPort instance

#### Inherited from

[`Lifecycle`](Lifecycle.md).[`diagnostics`](Lifecycle.md#diagnostics)

***

### emitter

#### Get Signature

> **get** **emitter**(): [`EmitterPort`](../interfaces/EmitterPort.md)\<[`LifecycleEventMap`](../type-aliases/LifecycleEventMap.md)\>

Defined in: [lifecycle.ts:82](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L82)

Access the emitter port used for lifecycle events.

Events include: 'transition', 'create', 'start', 'stop', 'destroy', 'error'.

##### Returns

[`EmitterPort`](../interfaces/EmitterPort.md)\<[`LifecycleEventMap`](../type-aliases/LifecycleEventMap.md)\>

The EmitterPort instance for lifecycle events

#### Inherited from

[`Lifecycle`](Lifecycle.md).[`emitter`](Lifecycle.md#emitter)

***

### logger

#### Get Signature

> **get** **logger**(): [`LoggerPort`](../interfaces/LoggerPort.md)

Defined in: [lifecycle.ts:98](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L98)

Access the logger port backing this lifecycle.

This logger is propagated to default adapters when not explicitly provided.

##### Returns

[`LoggerPort`](../interfaces/LoggerPort.md)

The LoggerPort instance

#### Inherited from

[`Lifecycle`](Lifecycle.md).[`logger`](Lifecycle.md#logger)

***

### queue

#### Get Signature

> **get** **queue**(): [`QueuePort`](../interfaces/QueuePort.md)

Defined in: [lifecycle.ts:89](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L89)

Access the queue port used to serialize hooks and enforce deadlines.

##### Returns

[`QueuePort`](../interfaces/QueuePort.md)

The QueuePort instance for running lifecycle hooks

#### Inherited from

[`Lifecycle`](Lifecycle.md).[`queue`](Lifecycle.md#queue)

***

### state

#### Get Signature

> **get** **state**(): [`LifecycleState`](../type-aliases/LifecycleState.md)

Defined in: [lifecycle.ts:112](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L112)

Get the current lifecycle state.

##### Returns

[`LifecycleState`](../type-aliases/LifecycleState.md)

The current state: 'created', 'started', 'stopped', or 'destroyed'

#### Inherited from

[`Lifecycle`](Lifecycle.md).[`state`](Lifecycle.md#state)

## Methods

### create()

> **create**(): `Promise`\<`void`\>

Defined in: [lifecycle.ts:210](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L210)

Create the lifecycle (idempotent no-op by default).

May be called before start in complex setups. Override onCreate() to add creation behavior.

#### Returns

`Promise`\<`void`\>

#### Throws

Error with code ORK1020 if the current state is not 'created'

#### Example

```ts
await lifecycle.create()
```

#### Inherited from

[`Lifecycle`](Lifecycle.md).[`create`](Lifecycle.md#create)

***

### destroy()

> **destroy**(): `Promise`\<`void`\>

Defined in: [lifecycle.ts:266](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L266)

Transition to 'destroyed' and remove all listeners.

Safe to call multiple times (idempotent). Invokes the onDestroy hook and removes all event listeners.

#### Returns

`Promise`\<`void`\>

#### Throws

Error with code ORK1021 if the hook times out

#### Throws

Error with code ORK1022 if the hook throws an error

#### Example

```ts
await lifecycle.destroy()
```

#### Inherited from

[`Lifecycle`](Lifecycle.md).[`destroy`](Lifecycle.md#destroy)

***

### off()

> **off**\<`T`\>(`evt`, `fn`): `this`

Defined in: [lifecycle.ts:167](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L167)

Unsubscribe a previously registered listener.

#### Type Parameters

##### T

`T` *extends* `"error"` \| `"start"` \| `"stop"` \| `"destroy"` \| `"create"` \| `"transition"`

Event key in the lifecycle event map

#### Parameters

##### evt

`T`

Event name to unsubscribe from

##### fn

(...`args`) => `void`

The exact listener function to remove (must be same reference used in `on`)

#### Returns

`this`

This lifecycle instance for chaining

#### Example

```ts
const handler = (state) => console.log(state)
lifecycle.on('transition', handler)
lifecycle.off('transition', handler)
```

#### Inherited from

[`Lifecycle`](Lifecycle.md).[`off`](Lifecycle.md#off)

***

### on()

> **on**\<`T`\>(`evt`, `fn`): `this`

Defined in: [lifecycle.ts:142](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L142)

Subscribe to a lifecycle event.

Supported events: 'transition', 'create', 'start', 'stop', 'destroy', 'error'.
The first 'transition' listener will receive the current state immediately when emitInitial is true (default).

#### Type Parameters

##### T

`T` *extends* `"error"` \| `"start"` \| `"stop"` \| `"destroy"` \| `"create"` \| `"transition"`

Event key in the lifecycle event map

#### Parameters

##### evt

`T`

Event name to subscribe to

##### fn

(...`args`) => `void`

Listener function receiving tuple-typed arguments for the event

#### Returns

`this`

This lifecycle instance for chaining

#### Example

```ts
lifecycle.on('transition', (state) => console.log('State:', state))
lifecycle.on('error', (err) => console.error('Lifecycle error:', err))
lifecycle.on('start', () => console.log('Started'))
```

#### Inherited from

[`Lifecycle`](Lifecycle.md).[`on`](Lifecycle.md#on)

***

### onCreate()

> `protected` **onCreate**(): `Promise`\<`void`\>

Defined in: [adapter.ts:42](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapter.ts#L42)

#### Returns

`Promise`\<`void`\>

#### Overrides

[`Lifecycle`](Lifecycle.md).[`onCreate`](Lifecycle.md#oncreate)

***

### onDestroy()

> `protected` **onDestroy**(): `Promise`\<`void`\>

Defined in: [adapter.ts:48](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapter.ts#L48)

#### Returns

`Promise`\<`void`\>

#### Overrides

[`Lifecycle`](Lifecycle.md).[`onDestroy`](Lifecycle.md#ondestroy)

***

### onStart()

> `protected` **onStart**(): `Promise`\<`void`\>

Defined in: [adapter.ts:44](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapter.ts#L44)

#### Returns

`Promise`\<`void`\>

#### Overrides

[`Lifecycle`](Lifecycle.md).[`onStart`](Lifecycle.md#onstart)

***

### onStop()

> `protected` **onStop**(): `Promise`\<`void`\>

Defined in: [adapter.ts:46](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapter.ts#L46)

#### Returns

`Promise`\<`void`\>

#### Overrides

[`Lifecycle`](Lifecycle.md).[`onStop`](Lifecycle.md#onstop)

***

### onTransition()

> `protected` **onTransition**(`_from`, `_to`, `_hook`): `Promise`\<`void`\>

Defined in: [lifecycle.ts:295](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L295)

#### Parameters

##### \_from

[`LifecycleState`](../type-aliases/LifecycleState.md)

##### \_to

[`LifecycleState`](../type-aliases/LifecycleState.md)

##### \_hook

[`LifecycleHook`](../type-aliases/LifecycleHook.md)

#### Returns

`Promise`\<`void`\>

#### Inherited from

[`Lifecycle`](Lifecycle.md).[`onTransition`](Lifecycle.md#ontransition)

***

### setState()

> `protected` **setState**(`next`): `void`

Defined in: [lifecycle.ts:115](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L115)

#### Parameters

##### next

[`LifecycleState`](../type-aliases/LifecycleState.md)

#### Returns

`void`

#### Inherited from

[`Lifecycle`](Lifecycle.md).[`setState`](Lifecycle.md#setstate)

***

### start()

> **start**(): `Promise`\<`void`\>

Defined in: [lifecycle.ts:229](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L229)

Transition from 'created' or 'stopped' to 'started'.

Invokes the onStart hook and emits 'start' and 'transition' events on success.

#### Returns

`Promise`\<`void`\>

#### Throws

Error with code ORK1020 if the transition is invalid

#### Throws

Error with code ORK1021 if the hook times out

#### Throws

Error with code ORK1022 if the hook throws an error

#### Example

```ts
await lifecycle.start()
```

#### Inherited from

[`Lifecycle`](Lifecycle.md).[`start`](Lifecycle.md#start)

***

### stop()

> **stop**(): `Promise`\<`void`\>

Defined in: [lifecycle.ts:248](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L248)

Transition from 'started' to 'stopped'.

Invokes the onStop hook and emits 'stop' and 'transition' events on success.

#### Returns

`Promise`\<`void`\>

#### Throws

Error with code ORK1020 if the transition is invalid (e.g., not currently 'started')

#### Throws

Error with code ORK1021 if the hook times out

#### Throws

Error with code ORK1022 if the hook throws an error

#### Example

```ts
await lifecycle.stop()
```

#### Inherited from

[`Lifecycle`](Lifecycle.md).[`stop`](Lifecycle.md#stop)

---

## Class: Container

[**@orkestrel/core**](../index.md)

***

# Class: Container

Defined in: [container.ts:71](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L71)

Minimal, strongly-typed DI container for tokens and providers.

Features
- Register value, factory, or class providers under token keys.
- Resolve single tokens or maps strictly (throws on missing) or optionally (returns undefined).
- Create child scopes that inherit providers; use using() to run scoped work with auto cleanup.
- Destroy lifecycle-owning instances deterministically.

## Example

```ts
import { Container, createToken } from '@orkestrel/core'

const A = createToken<number>('A')
const B = createToken<string>('B')
const C = createToken<{ a: number, b: string }>('C')

const c = new Container()
c.set(A, 1)
c.set(B, 'two')
c.register(C, { useFactory: (a, b) => ({ a, b }), inject: [A, B] })

const merged = c.resolve(C) // { a: 1, b: 'two' }
const { a, b } = c.resolve({ a: A, b: B })

await c.using(async (scope) => {
  // scoped overrides
  scope.set(A, 99)
  const { a: scopedA } = scope.resolve({ a: A }) // 99
  // scope destroyed automatically afterwards
})

await c.destroy() // stops and destroys owned Lifecycle instances
```

## Constructors

### Constructor

> **new Container**(`opts`): `Container`

Defined in: [container.ts:87](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L87)

Construct a Container with optional parent, logger, and diagnostic adapters.

#### Parameters

##### opts

[`ContainerOptions`](../interfaces/ContainerOptions.md) = `{}`

Configuration options:
- parent: Optional parent container to inherit providers from
- logger: Optional logger port for diagnostics
- diagnostic: Optional diagnostic port for error reporting

#### Returns

`Container`

## Accessors

### diagnostic

#### Get Signature

> **get** **diagnostic**(): [`DiagnosticPort`](../interfaces/DiagnosticPort.md)

Defined in: [container.ts:99](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L99)

Access the diagnostic port used by this container.

##### Returns

[`DiagnosticPort`](../interfaces/DiagnosticPort.md)

The configured DiagnosticPort instance

***

### logger

#### Get Signature

> **get** **logger**(): [`LoggerPort`](../interfaces/LoggerPort.md)

Defined in: [container.ts:106](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L106)

Access the logger port used by this container.

##### Returns

[`LoggerPort`](../interfaces/LoggerPort.md)

The configured LoggerPort instance

## Methods

### createChild()

> **createChild**(): `Container`

Defined in: [container.ts:263](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L263)

Create a child container that inherits providers from this container.

#### Returns

`Container`

A new Container instance with this container as its parent

#### Example

```ts
const child = container.createChild()
child.set(OverrideToken, newValue)
```

***

### destroy()

> **destroy**(): `Promise`\<`void`\>

Defined in: [container.ts:318](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L318)

Destroy owned Lifecycle instances (stop if needed, then destroy).

Idempotent - safe to call multiple times. Iterates through all registered instances,
stops any that are started, and destroys all that are disposable.

#### Returns

`Promise`\<`void`\>

#### Throws

AggregateLifecycleError with code ORK1016 if errors occur during destruction

#### Example

```ts
await container.destroy()
```

***

### get()

Optionally resolve a single token or a map of tokens; missing entries return undefined.

#### Param

Token to get, or a record/tuple of tokens to get into a map/tuple

#### Example

```ts
const maybeCfg = container.get(ConfigToken) // T | undefined
const { a, b } = container.get({ a: A, b: B }) // { a?: A, b?: B }
const [a, b] = container.get([A, B] as const) // [A | undefined, B | undefined]
```

#### Call Signature

> **get**\<`T`\>(`token`): `undefined` \| `T`

Defined in: [container.ts:218](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L218)

##### Type Parameters

###### T

`T`

##### Parameters

###### token

[`Token`](../type-aliases/Token.md)\<`T`\>

##### Returns

`undefined` \| `T`

#### Call Signature

> **get**\<`A`\>(`tokens`): \{ \[K in string \| number \| symbol\]: undefined \| A\[K\<K\>\] \}

Defined in: [container.ts:220](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L220)

##### Type Parameters

###### A

`A` *extends* readonly `unknown`[]

##### Parameters

###### tokens

[`InjectTuple`](../type-aliases/InjectTuple.md)\<`A`\>

##### Returns

\{ \[K in string \| number \| symbol\]: undefined \| A\[K\<K\>\] \}

#### Call Signature

> **get**\<`O`\>(`tokens`): \{ \[K in string \| number \| symbol\]: undefined \| O\[K\] \}

Defined in: [container.ts:222](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L222)

##### Type Parameters

###### O

`O` *extends* `Record`\<`string`, `unknown`\>

##### Parameters

###### tokens

[`InjectObject`](../type-aliases/InjectObject.md)\<`O`\>

##### Returns

\{ \[K in string \| number \| symbol\]: undefined \| O\[K\] \}

#### Call Signature

> **get**\<`TMap`\>(`tokens`): [`OptionalResolvedMap`](../type-aliases/OptionalResolvedMap.md)\<`TMap`\>

Defined in: [container.ts:224](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L224)

##### Type Parameters

###### TMap

`TMap` *extends* [`TokenRecord`](../type-aliases/TokenRecord.md)

##### Parameters

###### tokens

`TMap`

##### Returns

[`OptionalResolvedMap`](../type-aliases/OptionalResolvedMap.md)\<`TMap`\>

***

### has()

> **has**\<`T`\>(`token`): `boolean`

Defined in: [container.ts:176](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L176)

Check if a provider is available for the token (searches parent containers).

#### Type Parameters

##### T

`T`

Token value type

#### Parameters

##### token

[`Token`](../type-aliases/Token.md)\<`T`\>

The token to check

#### Returns

`boolean`

True if a provider is registered for the token, false otherwise

#### Example

```ts
if (container.has(ConfigToken)) {
  const config = container.resolve(ConfigToken)
}
```

***

### register()

Register a provider under a token.

Supported shapes
- Value: `{ useValue }`
- Factory: `{ useFactory }` with optional inject tuple/object or container arg
- Class: `{ useClass }` with optional inject tuple/object or container arg

#### Type Param

Token value type.

#### Param

The unique token to associate with the provider.

#### Param

The provider object or raw value.

#### Param

When true, prevents re-registration for the same token.

#### Example

```ts
// value
container.register(Port, { useValue: impl })
// factory with tuple inject
container.register(Port, { useFactory: (a, b) => make(a, b), inject: [A, B] })
// class with object inject
container.register(Port, { useClass: Impl, inject: { a: A, b: B } })
// lock to prevent override
container.register(Port, { useValue: impl }, true)
```

#### Call Signature

> **register**\<`T`, `A`\>(`token`, `provider`, `lock?`): `this`

Defined in: [container.ts:109](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L109)

##### Type Parameters

###### T

`T`

###### A

`A` *extends* readonly `unknown`[]

##### Parameters

###### token

[`Token`](../type-aliases/Token.md)\<`T`\>

###### provider

[`FactoryProviderWithTuple`](../type-aliases/FactoryProviderWithTuple.md)\<`T`, `A`\> | [`ClassProviderWithTuple`](../type-aliases/ClassProviderWithTuple.md)\<`T`, `A`\>

###### lock?

`boolean`

##### Returns

`this`

#### Call Signature

> **register**\<`T`, `O`\>(`token`, `provider`, `lock?`): `this`

Defined in: [container.ts:111](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L111)

##### Type Parameters

###### T

`T`

###### O

`O` *extends* `Record`\<`string`, `unknown`\>

##### Parameters

###### token

[`Token`](../type-aliases/Token.md)\<`T`\>

###### provider

[`FactoryProviderWithObject`](../type-aliases/FactoryProviderWithObject.md)\<`T`, `O`\> | [`ClassProviderWithObject`](../type-aliases/ClassProviderWithObject.md)\<`T`, `O`\>

###### lock?

`boolean`

##### Returns

`this`

#### Call Signature

> **register**\<`T`\>(`token`, `provider`, `lock?`): `this`

Defined in: [container.ts:113](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L113)

##### Type Parameters

###### T

`T`

##### Parameters

###### token

[`Token`](../type-aliases/Token.md)\<`T`\>

###### provider

`T` | [`ValueProvider`](../interfaces/ValueProvider.md)\<`T`\> | [`FactoryProviderNoDeps`](../type-aliases/FactoryProviderNoDeps.md)\<`T`\> | [`ClassProviderNoDeps`](../type-aliases/ClassProviderNoDeps.md)\<`T`\>

###### lock?

`boolean`

##### Returns

`this`

***

### resolve()

Strictly resolve a single token or a token map. Missing tokens cause ORK1006 failures.

#### Param

Token to resolve, or a record of tokens to resolve into a map.

#### Example

```ts
const { a, b } = container.resolve({ a: A, b: B })
const [a, b] = container.resolve([A, B] as const)
```

#### Call Signature

> **resolve**\<`T`\>(`token`): `T`

Defined in: [container.ts:181](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L181)

##### Type Parameters

###### T

`T`

##### Parameters

###### token

[`Token`](../type-aliases/Token.md)\<`T`\>

##### Returns

`T`

#### Call Signature

> **resolve**\<`O`\>(`tokens`): `O`

Defined in: [container.ts:183](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L183)

##### Type Parameters

###### O

`O` *extends* `Record`\<`string`, `unknown`\>

##### Parameters

###### tokens

[`InjectObject`](../type-aliases/InjectObject.md)\<`O`\>

##### Returns

`O`

#### Call Signature

> **resolve**\<`A`\>(`tokens`): `A`

Defined in: [container.ts:185](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L185)

##### Type Parameters

###### A

`A` *extends* readonly `unknown`[]

##### Parameters

###### tokens

[`InjectTuple`](../type-aliases/InjectTuple.md)\<`A`\>

##### Returns

`A`

#### Call Signature

> **resolve**\<`TMap`\>(`tokens`): [`ResolvedMap`](../type-aliases/ResolvedMap.md)\<`TMap`\>

Defined in: [container.ts:187](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L187)

##### Type Parameters

###### TMap

`TMap` *extends* [`TokenRecord`](../type-aliases/TokenRecord.md)

##### Parameters

###### tokens

`TMap`

##### Returns

[`ResolvedMap`](../type-aliases/ResolvedMap.md)\<`TMap`\>

***

### set()

> **set**\<`T`\>(`token`, `value`, `lock?`): `void`

Defined in: [container.ts:160](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L160)

Shorthand for registering a value provider.

#### Type Parameters

##### T

`T`

Token value type

#### Parameters

##### token

[`Token`](../type-aliases/Token.md)\<`T`\>

The token to register the value under

##### value

`T`

The value to register

##### lock?

`boolean`

When true, prevents re-registration for this token (default: false)
   *

#### Returns

`void`

void

#### Example

```ts
container.set(ConfigToken, { apiUrl: 'https://api.example.com' })
```

***

### using()

Run work inside an automatically destroyed child scope.

- using(fn): create child, run fn(child), always destroy child afterwards.
- using(apply, fn): create child, run apply(child) to register overrides, then fn(child).

#### Type Param

Return type of the work function.

#### Param

Work function, or an apply function when `arg2` is provided.

#### Param

Optional work function when using the (apply, fn) overload.

#### Example

```ts
const out = await container.using(async (scope) => {
  scope.set(A, 41)
  return scope.resolve(A) + 1
}) // => 42
```

#### Call Signature

> **using**(`fn`): `Promise`\<`void`\>

Defined in: [container.ts:266](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L266)

##### Parameters

###### fn

(`scope`) => `void` \| `Promise`\<`void`\>

##### Returns

`Promise`\<`void`\>

#### Call Signature

> **using**\<`T`\>(`fn`): `Promise`\<`T`\>

Defined in: [container.ts:268](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L268)

##### Type Parameters

###### T

`T`

##### Parameters

###### fn

(`scope`) => `T` \| `Promise`\<`T`\>

##### Returns

`Promise`\<`T`\>

#### Call Signature

> **using**\<`T`\>(`apply`, `fn`): `Promise`\<`T`\>

Defined in: [container.ts:270](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L270)

##### Type Parameters

###### T

`T`

##### Parameters

###### apply

(`scope`) => `void` \| `Promise`\<`void`\>

###### fn

(`scope`) => `T` \| `Promise`\<`T`\>

##### Returns

`Promise`\<`T`\>

---

## Class: DiagnosticAdapter

[**@orkestrel/core**](../index.md)

***

# Class: DiagnosticAdapter

Defined in: [adapters/diagnostic.ts:67](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/diagnostic.ts#L67)

Diagnostic adapter providing safe logging, error reporting, and telemetry.

Acts as a delegator to a LoggerPort with keyed message overrides for consistent
log levels and messages. Provides methods for logging (log), error reporting (error),
error construction and throwing (fail), building errors without throwing (help),
aggregating lifecycle errors (aggregate), and telemetry (metric/trace/event).

Never throws from safe methods (log, error, metric, trace, event). Only fail() and
aggregate() throw errors after logging them.

## Example

```ts
import { DiagnosticAdapter, ORCHESTRATOR_MESSAGES } from '@orkestrel/core'

const diag = new DiagnosticAdapter({ messages: ORCHESTRATOR_MESSAGES })
diag.log('info', 'orchestrator.phase', { phase: 'start' })

// Build and throw an error with a code
try {
  diag.fail('ORK1007', { scope: 'orchestrator', message: 'Duplicate registration' })
} catch (e) {
  console.error('Caught:', (e as any).code, (e as Error).message)
}

// Aggregate multiple errors
const errors = [new Error('task1 failed'), new Error('task2 failed')]
try {
  diag.aggregate('ORK1017', errors, { scope: 'orchestrator', message: 'Errors during destroy' })
} catch (e) {
  // e is an AggregateLifecycleError with .details and .errors
}
```

## Implements

- [`DiagnosticPort`](../interfaces/DiagnosticPort.md)

## Constructors

### Constructor

> **new DiagnosticAdapter**(`options?`): `DiagnosticAdapter`

Defined in: [adapters/diagnostic.ts:79](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/diagnostic.ts#L79)

Construct a DiagnosticAdapter with optional logger and message overrides.

#### Parameters

##### options?

[`DiagnosticAdapterOptions`](../interfaces/DiagnosticAdapterOptions.md)

Configuration options:
- logger: Optional logger port for emitting log entries (default: LoggerAdapter)
- messages: Array of diagnostic messages with keys, levels, and message templates
   *

#### Returns

`DiagnosticAdapter`

## Accessors

### logger

#### Get Signature

> **get** **logger**(): [`LoggerPort`](../interfaces/LoggerPort.md)

Defined in: [adapters/diagnostic.ts:91](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/diagnostic.ts#L91)

Access the logger port used by this diagnostic adapter.

##### Returns

[`LoggerPort`](../interfaces/LoggerPort.md)

The configured LoggerPort instance

## Methods

### aggregate()

> **aggregate**(`key`, `errors`, `context`): `never`

Defined in: [adapters/diagnostic.ts:184](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/diagnostic.ts#L184)

Aggregate multiple errors into a single structured AggregateDiagnosticError and throw it.

#### Parameters

##### key

`string`

Code used to identify the aggregate error (e.g., 'ORK1016')

##### errors

readonly (`Error` \| [`LifecycleErrorDetail`](../interfaces/LifecycleErrorDetail.md))[]

Array of Error instances to aggregate (or already-normalized details)

##### context

[`DiagnosticErrorContext`](../interfaces/DiagnosticErrorContext.md) & `object` = `{}`

Optional structured context including scope, message, helpUrl, and name

#### Returns

`never`

#### Throws

AggregateDiagnosticError containing details and errors

#### Example

```ts
const errs = [new Error('A'), new Error('B')]
diag.aggregate('ORK1017', errs, { scope: 'orchestrator' })
```

#### Implementation of

[`DiagnosticPort`](../interfaces/DiagnosticPort.md).[`aggregate`](../interfaces/DiagnosticPort.md#aggregate)

***

### error()

> **error**(`err`, `context`): `void`

Defined in: [adapters/diagnostic.ts:123](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/diagnostic.ts#L123)

Report an error to the logger with optional context fields.

#### Parameters

##### err

`unknown`

Error instance or value to report

##### context

[`DiagnosticErrorContext`](../interfaces/DiagnosticErrorContext.md) = `{}`

Optional structured context including code, scope, and extra fields

#### Returns

`void`

void (reports the error safely)
   *

#### Example

```ts
diag.error(new Error('boom'), { scope: 'orchestrator', code: 'ORK1013' })
```

#### Implementation of

[`DiagnosticPort`](../interfaces/DiagnosticPort.md).[`error`](../interfaces/DiagnosticPort.md#error)

***

### event()

> **event**(`name`, `payload?`): `void`

Defined in: [adapters/diagnostic.ts:242](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/diagnostic.ts#L242)

Emit a telemetry event with a name and payload.

#### Parameters

##### name

`string`

Event name (e.g., 'lifecycle.transition')

##### payload?

`Record`\<`string`, `unknown`\>

Arbitrary event payload
   *

#### Returns

`void`

void (emits an event entry)
   *

#### Example

```ts
diag.event('orchestrator.component.start', { token: 'Database' })
```

#### Implementation of

[`DiagnosticPort`](../interfaces/DiagnosticPort.md).[`event`](../interfaces/DiagnosticPort.md#event)

***

### fail()

> **fail**(`key`, `context`): `never`

Defined in: [adapters/diagnostic.ts:142](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/diagnostic.ts#L142)

Build an Error using a key/code, log it, and throw it.

#### Parameters

##### key

`string`

Code or message key (e.g., 'ORK1007') used to resolve message and severity

##### context

[`DiagnosticErrorContext`](../interfaces/DiagnosticErrorContext.md) & `object` = `{}`

Optional structured context including message override, helpUrl, name, and scope

#### Returns

`never`

#### Throws

Error with optional .code and .helpUrl properties
   *

#### Example

```ts
diag.fail('ORK1007', { scope: 'orchestrator', message: 'Duplicate registration' })
```

#### Implementation of

[`DiagnosticPort`](../interfaces/DiagnosticPort.md).[`fail`](../interfaces/DiagnosticPort.md#fail)

***

### help()

> **help**(`key`, `context`): `Error`

Defined in: [adapters/diagnostic.ts:164](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/diagnostic.ts#L164)

Build an Error using a key/code and return it (without throwing).

#### Parameters

##### key

`string`

Code or message key (e.g., 'ORK1010') used to resolve message and severity

##### context

[`DiagnosticErrorContext`](../interfaces/DiagnosticErrorContext.md) & `object` = `{}`

Optional structured context including message override, helpUrl, name, and scope

#### Returns

`Error`

The constructed Error instance
   *

#### Example

```ts
const timeoutErr = diag.help('ORK1021', { message: 'Hook onStart timed out' })
```

#### Implementation of

[`DiagnosticPort`](../interfaces/DiagnosticPort.md).[`help`](../interfaces/DiagnosticPort.md#help)

***

### log()

> **log**(`level`, `message`, `fields?`): `void`

Defined in: [adapters/diagnostic.ts:106](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/diagnostic.ts#L106)

Write a log entry with a level, message key, and optional structured fields.

#### Parameters

##### level

[`LogLevel`](../type-aliases/LogLevel.md)

Fallback log level when the key is not found in the message map

##### message

`string`

Message key or literal message string

##### fields?

`Record`\<`string`, `unknown`\>

Optional structured data to include with the log entry

#### Returns

`void`

void (logs the message if possible)
   *

#### Example

```ts
diag.log('info', 'orchestrator.phase', { phase: 'start', layer: 1 })
```

#### Implementation of

[`DiagnosticPort`](../interfaces/DiagnosticPort.md).[`log`](../interfaces/DiagnosticPort.md#log)

***

### metric()

> **metric**(`name`, `value`, `tags?`): `void`

Defined in: [adapters/diagnostic.ts:207](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/diagnostic.ts#L207)

Emit a metric with a numeric value and optional tags.

#### Parameters

##### name

`string`

Metric name (e.g., 'queue.size')

##### value

`number`

Numeric value to record

##### tags?

`Record`\<`string`, `string` \| `number` \| `boolean`\>

Optional tags to include with the metric

   *

#### Returns

`void`

#### Example

```ts
diag.metric('queue.size', 42, { queueName: 'tasks' })
```

#### Implementation of

[`DiagnosticPort`](../interfaces/DiagnosticPort.md).[`metric`](../interfaces/DiagnosticPort.md#metric)

***

### trace()

> **trace**(`name`, `payload?`): `void`

Defined in: [adapters/diagnostic.ts:225](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/diagnostic.ts#L225)

Emit a trace span with a name and optional fields.

#### Parameters

##### name

`string`

Span name (e.g., 'orchestrator.start')

##### payload?

`Record`\<`string`, `unknown`\>

Optional structured fields for the trace

#### Returns

`void`

void (emits a trace entry)
   *

#### Example

```ts
diag.trace('lifecycle.transition', { from: 'created', to: 'started' })
```

#### Implementation of

[`DiagnosticPort`](../interfaces/DiagnosticPort.md).[`trace`](../interfaces/DiagnosticPort.md#trace)

---

## Class: EmitterAdapter\<EMap\>

[**@orkestrel/core**](../index.md)

***

# Class: EmitterAdapter\<EMap\>

Defined in: [adapters/emitter.ts:25](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/emitter.ts#L25)

In-memory event emitter implementation with typed tuple-based events.

Stores per-event listeners in sets and invokes them synchronously in insertion order.
Errors thrown by listeners are isolated via safeInvoke to prevent cascading failures.

## Example

```ts
import { EmitterAdapter } from '@orkestrel/core'
type Events = { start: [], data: [string], error: [Error] }
const emitter = new EmitterAdapter<Events>()
const onData = (s: string) => console.log('received:', s)
emitter.on('data', onData)
emitter.emit('start')
emitter.emit('data', 'hello world')
emitter.off('data', onData)
emitter.removeAllListeners()
```

## Type Parameters

### EMap

`EMap` *extends* [`EventMap`](../type-aliases/EventMap.md) = [`EventMap`](../type-aliases/EventMap.md)

## Implements

- [`EmitterPort`](../interfaces/EmitterPort.md)\<`EMap`\>

## Constructors

### Constructor

> **new EmitterAdapter**\<`EMap`\>(`options`): `EmitterAdapter`\<`EMap`\>

Defined in: [adapters/emitter.ts:40](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/emitter.ts#L40)

Construct an EmitterAdapter with optional logger and diagnostic ports.

#### Parameters

##### options

[`EmitterAdapterOptions`](../interfaces/EmitterAdapterOptions.md) = `{}`

Configuration options:
- logger: Optional logger port used for emitting any diagnostics
- diagnostic: Optional diagnostic port for telemetry and errors
   *

#### Returns

`EmitterAdapter`\<`EMap`\>

## Accessors

### diagnostic

#### Get Signature

> **get** **diagnostic**(): [`DiagnosticPort`](../interfaces/DiagnosticPort.md)

Defined in: [adapters/emitter.ts:57](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/emitter.ts#L57)

Access the diagnostic port used by this emitter.

##### Returns

[`DiagnosticPort`](../interfaces/DiagnosticPort.md)

The configured DiagnosticPort instance

***

### logger

#### Get Signature

> **get** **logger**(): [`LoggerPort`](../interfaces/LoggerPort.md)

Defined in: [adapters/emitter.ts:50](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/emitter.ts#L50)

Access the logger port used by this emitter.

##### Returns

[`LoggerPort`](../interfaces/LoggerPort.md)

The configured LoggerPort instance

## Methods

### emit()

> **emit**\<`E`\>(`event`, ...`args`): `void`

Defined in: [adapters/emitter.ts:126](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/emitter.ts#L126)

Emit an event with arguments, invoking all registered listeners synchronously.

#### Type Parameters

##### E

`E` *extends* `string`

#### Parameters

##### event

`E`

Event name (key in the event map)

##### args

...`EMap`\[`E`\]

Arguments matching the event's tuple signature

#### Returns

`void`

void (invokes listeners synchronously if any are registered)
   *

#### Example

```ts
emitter.emit('data', 'hello world')
```

#### Implementation of

[`EmitterPort`](../interfaces/EmitterPort.md).[`emit`](../interfaces/EmitterPort.md#emit)

***

### off()

> **off**\<`E`\>(`event`, `fn`): `this`

Defined in: [adapters/emitter.ts:105](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/emitter.ts#L105)

Remove a previously registered listener for a specific event.

#### Type Parameters

##### E

`E` *extends* `string`

#### Parameters

##### event

`E`

Event name (key in the event map)

##### fn

[`EmitterListener`](../type-aliases/EmitterListener.md)\<`EMap`, `E`\>

The exact listener function to remove

#### Returns

`this`

This emitter instance for method chaining
   *

#### Example

```ts
const handler = (s: string) => console.log(s)
emitter.on('data', handler)
emitter.off('data', handler)
```

#### Implementation of

[`EmitterPort`](../interfaces/EmitterPort.md).[`off`](../interfaces/EmitterPort.md#off)

***

### on()

> **on**\<`E`\>(`event`, `fn`): `this`

Defined in: [adapters/emitter.ts:86](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/emitter.ts#L86)

Register a listener function for a specific event.

#### Type Parameters

##### E

`E` *extends* `string`

#### Parameters

##### event

`E`

Event name (key in the event map)

##### fn

[`EmitterListener`](../type-aliases/EmitterListener.md)\<`EMap`, `E`\>

Listener function that receives tuple-typed arguments matching the event signature

#### Returns

`this`

This emitter instance for method chaining
   *

#### Example

```ts
emitter.on('data', (value: string) => console.log('data:', value))
```

#### Implementation of

[`EmitterPort`](../interfaces/EmitterPort.md).[`on`](../interfaces/EmitterPort.md#on)

***

### removeAllListeners()

> **removeAllListeners**(): `void`

Defined in: [adapters/emitter.ts:147](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/emitter.ts#L147)

Remove all registered listeners for all events.

#### Returns

`void`

void (clears all event listener registrations)

#### Example

```ts
emitter.removeAllListeners()
```

#### Implementation of

[`EmitterPort`](../interfaces/EmitterPort.md).[`removeAllListeners`](../interfaces/EmitterPort.md#removealllisteners)

---

## Class: EventAdapter

[**@orkestrel/core**](../index.md)

***

# Class: EventAdapter

Defined in: [adapters/event.ts:25](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/event.ts#L25)

Topic-based asynchronous publish-subscribe event bus.

Provides an in-memory event bus where handlers can subscribe to topics and publishers can emit payloads.
Supports both sequential (default) and concurrent handler invocation modes. Errors thrown by handlers
are isolated and reported via the optional onError callback and diagnostic port.

## Example

```ts
import { EventAdapter } from '@orkestrel/core'
type Events = { 'user:created': { id: string, name: string }, 'user:deleted': { id: string } }
const bus = new EventAdapter<Events>({ sequential: true })
const unsubscribe = await bus.subscribe('user:created', async (payload) => {
  console.log('User created:', payload.id, payload.name)
})
await bus.publish('user:created', { id: 'u1', name: 'Alice' })
await unsubscribe()
```

## Implements

- [`EventPort`](../interfaces/EventPort.md)

## Constructors

### Constructor

> **new EventAdapter**(`options`): `EventAdapter`

Defined in: [adapters/event.ts:43](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/event.ts#L43)

Construct an EventAdapter with optional configuration.

#### Parameters

##### options

[`EventAdapterOptions`](../interfaces/EventAdapterOptions.md) = `{}`

Configuration options:
- onError: Optional callback invoked when a handler throws an error
- sequential: When true (default), handlers are invoked sequentially; when false, handlers run concurrently
- logger: Optional logger port for diagnostics
- diagnostic: Optional diagnostic port for telemetry

#### Returns

`EventAdapter`

## Accessors

### diagnostic

#### Get Signature

> **get** **diagnostic**(): [`DiagnosticPort`](../interfaces/DiagnosticPort.md)

Defined in: [adapters/event.ts:63](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/event.ts#L63)

Access the diagnostic port used by this event adapter.

##### Returns

[`DiagnosticPort`](../interfaces/DiagnosticPort.md)

The configured DiagnosticPort instance

***

### logger

#### Get Signature

> **get** **logger**(): [`LoggerPort`](../interfaces/LoggerPort.md)

Defined in: [adapters/event.ts:56](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/event.ts#L56)

Access the logger port used by this event adapter.

##### Returns

[`LoggerPort`](../interfaces/LoggerPort.md)

The configured LoggerPort instance

## Methods

### publish()

> **publish**\<`T`\>(`topic`, `payload`): `Promise`\<`void`\>

Defined in: [adapters/event.ts:83](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/event.ts#L83)

Publish a payload to a topic, invoking all subscribed handlers.

In sequential mode (default), handlers are awaited one-by-one in subscription order.
In concurrent mode, handlers are invoked in parallel via Promise.all.
Handler errors are isolated and reported via onError and diagnostic callbacks.

#### Type Parameters

##### T

`T`

#### Parameters

##### topic

`string`

The topic name to publish to

##### payload

`T`

The payload value to pass to all subscribed handlers

#### Returns

`Promise`\<`void`\>

#### Example

```ts
await bus.publish('user:created', { id: 'u123', name: 'Bob' })
```

#### Implementation of

[`EventPort`](../interfaces/EventPort.md).[`publish`](../interfaces/EventPort.md#publish)

***

### subscribe()

> **subscribe**\<`T`\>(`topic`, `handler`): `Promise`\<() => `void` \| `Promise`\<`void`\>\>

Defined in: [adapters/event.ts:131](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/event.ts#L131)

Subscribe a handler function to a topic.

The handler will be invoked whenever a payload is published to the topic.
Returns an unsubscribe function to remove the handler later.

#### Type Parameters

##### T

`T`

#### Parameters

##### topic

`string`

The topic name to subscribe to

##### handler

[`EventHandler`](../type-aliases/EventHandler.md)\<`T`\>

Handler function (sync or async) that receives the topic payload

#### Returns

`Promise`\<() => `void` \| `Promise`\<`void`\>\>

An async unsubscribe function that removes the handler when called

#### Example

```ts
const unsubscribe = await bus.subscribe('user:created', async (user) => {
  console.log('New user:', user.name)
})
// Later, to unsubscribe:
await unsubscribe()
```

#### Implementation of

[`EventPort`](../interfaces/EventPort.md).[`subscribe`](../interfaces/EventPort.md#subscribe)

***

### topics()

> **topics**(): readonly `string`[]

Defined in: [adapters/event.ts:155](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/event.ts#L155)

List all currently active topic names that have at least one subscriber.

#### Returns

readonly `string`[]

A read-only array of topic name strings

#### Example

```ts
console.log('Active topics:', bus.topics())
// => ['user:created', 'user:deleted']
```

#### Implementation of

[`EventPort`](../interfaces/EventPort.md).[`topics`](../interfaces/EventPort.md#topics)

---

## Class: LayerAdapter

[**@orkestrel/core**](../index.md)

***

# Class: LayerAdapter

Defined in: [adapters/layer.ts:30](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/layer.ts#L30)

Topological layering adapter using Kahn's algorithm for dependency ordering.

Computes deterministic layers from a dependency graph in O(V+E) time. Each layer contains
tokens with no remaining dependencies on earlier layers. Validates that all dependencies
exist and detects cycles; preserves insertion order within each layer for determinism.

## Example

```ts
import { LayerAdapter, createToken } from '@orkestrel/core'
const A = createToken('A')
const B = createToken('B')
const C = createToken('C')
const layer = new LayerAdapter()
const nodes = [
  { token: A, dependencies: [] },
  { token: B, dependencies: [A] },
  { token: C, dependencies: [A, B] },
]
const layers = layer.compute(nodes)
// => [[A], [B, C]]
```

## Implements

- [`LayerPort`](../interfaces/LayerPort.md)

## Constructors

### Constructor

> **new LayerAdapter**(`options`): `LayerAdapter`

Defined in: [adapters/layer.ts:42](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/layer.ts#L42)

Construct a LayerAdapter with optional logger and diagnostic ports.

#### Parameters

##### options

[`LayerAdapterOptions`](../interfaces/LayerAdapterOptions.md) = `{}`

Configuration options:
- logger: Optional logger port for diagnostics
- diagnostic: Optional diagnostic port for validation errors
   *

#### Returns

`LayerAdapter`

## Accessors

### diagnostic

#### Get Signature

> **get** **diagnostic**(): [`DiagnosticPort`](../interfaces/DiagnosticPort.md)

Defined in: [adapters/layer.ts:59](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/layer.ts#L59)

Access the diagnostic port used by this layer adapter for validation errors and tracing.

##### Returns

[`DiagnosticPort`](../interfaces/DiagnosticPort.md)

The configured DiagnosticPort instance

***

### logger

#### Get Signature

> **get** **logger**(): [`LoggerPort`](../interfaces/LoggerPort.md)

Defined in: [adapters/layer.ts:52](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/layer.ts#L52)

Access the logger port used by this layer adapter.

##### Returns

[`LoggerPort`](../interfaces/LoggerPort.md)

The configured LoggerPort instance

## Methods

### compute()

> **compute**\<`T`\>(`nodes`): [`Token`](../type-aliases/Token.md)\<`T`\>[][]

Defined in: [adapters/layer.ts:84](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/layer.ts#L84)

Compute topological layers for the given dependency graph using Kahn's algorithm.

Produces an array of layers where each layer contains tokens that have no remaining
dependencies on previous layers. Tokens within a layer are ordered by insertion order
in the input nodes array. Validates that all dependencies exist and detects cycles.

#### Type Parameters

##### T

`T`

Token value type

#### Parameters

##### nodes

readonly [`LayerNode`](../interfaces/LayerNode.md)\<`T`\>[]

Array of nodes, each with a token and its dependencies

#### Returns

[`Token`](../type-aliases/Token.md)\<`T`\>[][]

Array of layers, each layer is an array of tokens with no remaining dependencies

#### Throws

Error with code ORK1008 if a dependency references an unknown token

#### Throws

Error with code ORK1009 if a cycle is detected in the dependency graph

#### Example

```ts
const layers = layer.compute([
  { token: Database, dependencies: [] },
  { token: UserService, dependencies: [Database] },
  { token: ApiServer, dependencies: [UserService] },
])
// => [[Database], [UserService], [ApiServer]]
```

#### Implementation of

[`LayerPort`](../interfaces/LayerPort.md).[`compute`](../interfaces/LayerPort.md#compute)

***

### group()

> **group**\<`T`\>(`tokens`, `layers`): [`Token`](../type-aliases/Token.md)\<`T`\>[][]

Defined in: [adapters/layer.ts:160](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/layer.ts#L160)

Group tokens by their layer index in reverse order (highest layer first).

Used for stop and destroy operations that need to process components in reverse
dependency order. Tokens are grouped by their layer index from the original layering,
then iterated in descending order so dependent components are processed before their
dependencies.

#### Type Parameters

##### T

`T`

Token value type

#### Parameters

##### tokens

readonly [`Token`](../type-aliases/Token.md)\<`T`\>[]

Tokens to group

##### layers

readonly readonly [`Token`](../type-aliases/Token.md)\<`T`\>[][]

Layers as returned by compute()

#### Returns

[`Token`](../type-aliases/Token.md)\<`T`\>[][]

Groups of tokens ordered from highest layer to lowest; input order is preserved within groups

#### Example

```ts
const layers = [[A], [B], [C]]
const tokensToStop = [B, C]
const groups = layer.group(tokensToStop, layers)
// => [[C], [B]] (reverse order for safe teardown)
```

#### Implementation of

[`LayerPort`](../interfaces/LayerPort.md).[`group`](../interfaces/LayerPort.md#group)

---

## Abstract Class: Lifecycle

[**@orkestrel/core**](../index.md)

***

# Abstract Class: Lifecycle

Defined in: [lifecycle.ts:44](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L44)

Abstract deterministic lifecycle with hook timeouts and events.

States: 'created' → 'started' → 'stopped' → 'destroyed'.
Override protected hooks (onCreate/onStart/onStop/onDestroy/onTransition) to implement behavior.
Use .on('transition' | 'create' | 'start' | 'stop' | 'destroy' | 'error') to observe lifecycle events.

Options
-------
- timeouts: number of milliseconds to cap each hook (default: 5000).
- emitInitial: when true (default), first transition listener receives the current state immediately.
- emitter: custom EmitterPort to receive events.
- queue: custom QueuePort to serialize hooks and apply deadlines.
- logger/diagnostic: ports used by default adapters and error reporting.

## Example

```ts
import { Lifecycle } from '@orkestrel/core'

class Cache extends Lifecycle {
  private map = new Map<string, string>()
  protected async onStart() { // warm up, connect, etc. }
  protected async onStop() { this.map.clear() }
}

const c = new Cache({ timeouts: 2000 })
c.on('transition', (s) => console.log('state:', s))
await c.start()
await c.stop()
await c.destroy()
```

## Extended by

- [`Adapter`](Adapter.md)

## Constructors

### Constructor

> **new Lifecycle**(`opts`): `Lifecycle`

Defined in: [lifecycle.ts:65](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L65)

Construct a Lifecycle with optional configuration for timeouts, emitters, queue, logger, and diagnostic ports.

#### Parameters

##### opts

[`LifecycleOptions`](../interfaces/LifecycleOptions.md) = `{}`

Configuration options:
- timeouts: Timeout in milliseconds for each lifecycle hook (default: 5000)
- emitInitial: Whether to emit the current state immediately on first transition listener (default: true)
- emitter: Optional custom emitter port
- queue: Optional custom queue port for serializing hooks
- logger: Optional logger port
- diagnostic: Optional diagnostic port for telemetry and errors

#### Returns

`Lifecycle`

## Accessors

### diagnostics

#### Get Signature

> **get** **diagnostics**(): [`DiagnosticPort`](../interfaces/DiagnosticPort.md)

Defined in: [lifecycle.ts:105](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L105)

Access the diagnostic port used for telemetry and error reporting.

##### Returns

[`DiagnosticPort`](../interfaces/DiagnosticPort.md)

The DiagnosticPort instance

***

### emitter

#### Get Signature

> **get** **emitter**(): [`EmitterPort`](../interfaces/EmitterPort.md)\<[`LifecycleEventMap`](../type-aliases/LifecycleEventMap.md)\>

Defined in: [lifecycle.ts:82](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L82)

Access the emitter port used for lifecycle events.

Events include: 'transition', 'create', 'start', 'stop', 'destroy', 'error'.

##### Returns

[`EmitterPort`](../interfaces/EmitterPort.md)\<[`LifecycleEventMap`](../type-aliases/LifecycleEventMap.md)\>

The EmitterPort instance for lifecycle events

***

### logger

#### Get Signature

> **get** **logger**(): [`LoggerPort`](../interfaces/LoggerPort.md)

Defined in: [lifecycle.ts:98](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L98)

Access the logger port backing this lifecycle.

This logger is propagated to default adapters when not explicitly provided.

##### Returns

[`LoggerPort`](../interfaces/LoggerPort.md)

The LoggerPort instance

***

### queue

#### Get Signature

> **get** **queue**(): [`QueuePort`](../interfaces/QueuePort.md)

Defined in: [lifecycle.ts:89](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L89)

Access the queue port used to serialize hooks and enforce deadlines.

##### Returns

[`QueuePort`](../interfaces/QueuePort.md)

The QueuePort instance for running lifecycle hooks

***

### state

#### Get Signature

> **get** **state**(): [`LifecycleState`](../type-aliases/LifecycleState.md)

Defined in: [lifecycle.ts:112](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L112)

Get the current lifecycle state.

##### Returns

[`LifecycleState`](../type-aliases/LifecycleState.md)

The current state: 'created', 'started', 'stopped', or 'destroyed'

## Methods

### create()

> **create**(): `Promise`\<`void`\>

Defined in: [lifecycle.ts:210](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L210)

Create the lifecycle (idempotent no-op by default).

May be called before start in complex setups. Override onCreate() to add creation behavior.

#### Returns

`Promise`\<`void`\>

#### Throws

Error with code ORK1020 if the current state is not 'created'

#### Example

```ts
await lifecycle.create()
```

***

### destroy()

> **destroy**(): `Promise`\<`void`\>

Defined in: [lifecycle.ts:266](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L266)

Transition to 'destroyed' and remove all listeners.

Safe to call multiple times (idempotent). Invokes the onDestroy hook and removes all event listeners.

#### Returns

`Promise`\<`void`\>

#### Throws

Error with code ORK1021 if the hook times out

#### Throws

Error with code ORK1022 if the hook throws an error

#### Example

```ts
await lifecycle.destroy()
```

***

### off()

> **off**\<`T`\>(`evt`, `fn`): `this`

Defined in: [lifecycle.ts:167](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L167)

Unsubscribe a previously registered listener.

#### Type Parameters

##### T

`T` *extends* `"error"` \| `"start"` \| `"stop"` \| `"destroy"` \| `"create"` \| `"transition"`

Event key in the lifecycle event map

#### Parameters

##### evt

`T`

Event name to unsubscribe from

##### fn

(...`args`) => `void`

The exact listener function to remove (must be same reference used in `on`)

#### Returns

`this`

This lifecycle instance for chaining

#### Example

```ts
const handler = (state) => console.log(state)
lifecycle.on('transition', handler)
lifecycle.off('transition', handler)
```

***

### on()

> **on**\<`T`\>(`evt`, `fn`): `this`

Defined in: [lifecycle.ts:142](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L142)

Subscribe to a lifecycle event.

Supported events: 'transition', 'create', 'start', 'stop', 'destroy', 'error'.
The first 'transition' listener will receive the current state immediately when emitInitial is true (default).

#### Type Parameters

##### T

`T` *extends* `"error"` \| `"start"` \| `"stop"` \| `"destroy"` \| `"create"` \| `"transition"`

Event key in the lifecycle event map

#### Parameters

##### evt

`T`

Event name to subscribe to

##### fn

(...`args`) => `void`

Listener function receiving tuple-typed arguments for the event

#### Returns

`this`

This lifecycle instance for chaining

#### Example

```ts
lifecycle.on('transition', (state) => console.log('State:', state))
lifecycle.on('error', (err) => console.error('Lifecycle error:', err))
lifecycle.on('start', () => console.log('Started'))
```

***

### onCreate()

> `protected` **onCreate**(): `Promise`\<`void`\>

Defined in: [lifecycle.ts:283](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L283)

#### Returns

`Promise`\<`void`\>

***

### onDestroy()

> `protected` **onDestroy**(): `Promise`\<`void`\>

Defined in: [lifecycle.ts:292](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L292)

#### Returns

`Promise`\<`void`\>

***

### onStart()

> `protected` **onStart**(): `Promise`\<`void`\>

Defined in: [lifecycle.ts:286](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L286)

#### Returns

`Promise`\<`void`\>

***

### onStop()

> `protected` **onStop**(): `Promise`\<`void`\>

Defined in: [lifecycle.ts:289](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L289)

#### Returns

`Promise`\<`void`\>

***

### onTransition()

> `protected` **onTransition**(`_from`, `_to`, `_hook`): `Promise`\<`void`\>

Defined in: [lifecycle.ts:295](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L295)

#### Parameters

##### \_from

[`LifecycleState`](../type-aliases/LifecycleState.md)

##### \_to

[`LifecycleState`](../type-aliases/LifecycleState.md)

##### \_hook

[`LifecycleHook`](../type-aliases/LifecycleHook.md)

#### Returns

`Promise`\<`void`\>

***

### setState()

> `protected` **setState**(`next`): `void`

Defined in: [lifecycle.ts:115](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L115)

#### Parameters

##### next

[`LifecycleState`](../type-aliases/LifecycleState.md)

#### Returns

`void`

***

### start()

> **start**(): `Promise`\<`void`\>

Defined in: [lifecycle.ts:229](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L229)

Transition from 'created' or 'stopped' to 'started'.

Invokes the onStart hook and emits 'start' and 'transition' events on success.

#### Returns

`Promise`\<`void`\>

#### Throws

Error with code ORK1020 if the transition is invalid

#### Throws

Error with code ORK1021 if the hook times out

#### Throws

Error with code ORK1022 if the hook throws an error

#### Example

```ts
await lifecycle.start()
```

***

### stop()

> **stop**(): `Promise`\<`void`\>

Defined in: [lifecycle.ts:248](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/lifecycle.ts#L248)

Transition from 'started' to 'stopped'.

Invokes the onStop hook and emits 'stop' and 'transition' events on success.

#### Returns

`Promise`\<`void`\>

#### Throws

Error with code ORK1020 if the transition is invalid (e.g., not currently 'started')

#### Throws

Error with code ORK1021 if the hook times out

#### Throws

Error with code ORK1022 if the hook throws an error

#### Example

```ts
await lifecycle.stop()
```

---

## Class: LoggerAdapter

[**@orkestrel/core**](../index.md)

***

# Class: LoggerAdapter

Defined in: [adapters/logger.ts:17](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/logger.ts#L17)

Minimal console-backed logger implementation that routes log messages by level.

Routes log messages to the appropriate console method based on level (debug/info/warn/error).
Swallows any console errors to avoid cascading failures.

## Example

```ts
import { LoggerAdapter } from '@orkestrel/core'
const logger = new LoggerAdapter()
logger.log('info', 'Application started', { version: '1.0.0', user: 'alice' })
logger.log('error', 'Failed to connect', { retries: 3 })
```

## Implements

- [`LoggerPort`](../interfaces/LoggerPort.md)

## Constructors

### Constructor

> **new LoggerAdapter**(): `LoggerAdapter`

#### Returns

`LoggerAdapter`

## Methods

### log()

> **log**(`level`, `message`, `fields`): `void`

Defined in: [adapters/logger.ts:31](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/logger.ts#L31)

Log a message with the specified level and optional structured fields.

#### Parameters

##### level

[`LogLevel`](../type-aliases/LogLevel.md)

Log level: 'debug', 'info', 'warn', or 'error'

##### message

`string`

Human-readable log message

##### fields

`Record`\<`string`, `unknown`\> = `{}`

Optional structured data to include with the log entry

#### Returns

`void`

void (writes to console methods)

#### Example

```ts
logger.log('info', 'User logged in', { userId: '123', sessionId: 'abc' })
```

#### Implementation of

[`LoggerPort`](../interfaces/LoggerPort.md).[`log`](../interfaces/LoggerPort.md#log)

---

## Class: NoopLogger

[**@orkestrel/core**](../index.md)

***

# Class: NoopLogger

Defined in: [adapters/logger.ts:57](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/logger.ts#L57)

Silent logger implementation that discards all log messages.

Useful for tests or when you need to disable logging entirely without changing code.

## Example

```ts
import { NoopLogger } from '@orkestrel/core'
const logger = new NoopLogger()
logger.log('info', 'This will not be logged')
```

## Implements

- [`LoggerPort`](../interfaces/LoggerPort.md)

## Constructors

### Constructor

> **new NoopLogger**(): `NoopLogger`

#### Returns

`NoopLogger`

## Methods

### log()

> **log**(`_level`, `_message`, `_fields?`): `void`

Defined in: [adapters/logger.ts:72](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/logger.ts#L72)

No-op log method that intentionally does nothing with log messages.

#### Parameters

##### \_level

[`LogLevel`](../type-aliases/LogLevel.md)

Log level (ignored)

##### \_message

`string`

Log message (ignored)

##### \_fields?

`Record`\<`string`, `unknown`\>

Optional fields (ignored)

#### Returns

`void`

void

#### Example

```ts
const logger = new NoopLogger()
logger.log('warn', 'dropped')
```

#### Implementation of

[`LoggerPort`](../interfaces/LoggerPort.md).[`log`](../interfaces/LoggerPort.md#log)

---

## Class: Orchestrator

[**@orkestrel/core**](../index.md)

***

# Class: Orchestrator

Defined in: [orchestrator.ts:82](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L82)

Deterministic lifecycle runner that starts, stops, and destroys components in dependency order.

Responsibilities
- Validates dependency graphs (unknown dependencies and cycles are rejected).
- Guards providers to ensure synchronous creation (no async factories/values).
- Executes lifecycle phases in topological layers with optional concurrency and per-phase timeouts.
- Aggregates failures per phase with stable diagnostic codes.
- Supports telemetry via events and an optional tracer.

## Example

```ts
import { Orchestrator, Container, Adapter, createToken, register } from '@orkestrel/core'

class A extends Adapter {}
class B extends Adapter {}
const TA = createToken<A>('A')
const TB = createToken<B>('B')

const c = new Container()
const app = new Orchestrator(c)
await app.start([
  register(TA, { useFactory: () => new A() }),
  register(TB, { useFactory: () => new B() }, { dependencies: [TA] }),
])
await app.destroy()
```

## Constructors

### Constructor

> **new Orchestrator**(`containerOrOpts?`, `maybeOpts?`): `Orchestrator`

Defined in: [orchestrator.ts:105](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L105)

Construct an Orchestrator bound to a container and optional runtime ports.

You can either pass an existing Container, or pass options to construct with a new internal Container using
the same logger/diagnostic by default, or provide both.

#### Parameters

##### containerOrOpts?

A Container instance to bind, or OrchestratorOptions to construct a new one.

[`Container`](Container.md) | [`OrchestratorOptions`](../interfaces/OrchestratorOptions.md)

##### maybeOpts?

[`OrchestratorOptions`](../interfaces/OrchestratorOptions.md)

Optional OrchestratorOptions when the first argument is a Container.

#### Returns

`Orchestrator`

A new Orchestrator instance configured with provided or default ports.

## Accessors

### container

#### Get Signature

> **get** **container**(): [`Container`](Container.md)

Defined in: [orchestrator.ts:134](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L134)

Access the underlying Container bound to this orchestrator.

##### Returns

[`Container`](Container.md)

The Container used for provider registration and resolution.

***

### diagnostic

#### Get Signature

> **get** **diagnostic**(): [`DiagnosticPort`](../interfaces/DiagnosticPort.md)

Defined in: [orchestrator.ts:162](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L162)

Access the diagnostic port for logging, metrics, traces, and errors.

##### Returns

[`DiagnosticPort`](../interfaces/DiagnosticPort.md)

The DiagnosticPort for telemetry and error reporting.

***

### layer

#### Get Signature

> **get** **layer**(): [`LayerPort`](../interfaces/LayerPort.md)

Defined in: [orchestrator.ts:141](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L141)

Access the layering adapter used to compute dependency layers.

##### Returns

[`LayerPort`](../interfaces/LayerPort.md)

The LayerPort responsible for computing and grouping layers.

***

### logger

#### Get Signature

> **get** **logger**(): [`LoggerPort`](../interfaces/LoggerPort.md)

Defined in: [orchestrator.ts:155](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L155)

Access the logger port in use (propagated to internal adapters when not provided).

##### Returns

[`LoggerPort`](../interfaces/LoggerPort.md)

The LoggerPort for logging messages.

***

### queue

#### Get Signature

> **get** **queue**(): [`QueuePort`](../interfaces/QueuePort.md)

Defined in: [orchestrator.ts:148](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L148)

Access the queue adapter used to run per-layer jobs with optional concurrency.

##### Returns

[`QueuePort`](../interfaces/QueuePort.md)

The QueuePort used to schedule and execute tasks.

## Methods

### destroy()

> **destroy**(): `Promise`\<`void`\>

Defined in: [orchestrator.ts:331](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L331)

Stop (when needed) and destroy all components, then destroy the container.
Aggregates ORK1017 on failure and includes container cleanup errors.

#### Returns

`Promise`\<`void`\>

A promise that resolves when all components and the container are destroyed.

#### Example

```ts
await app.destroy() // ensures stop then destroy for all Lifecycle components
```

***

### register()

> **register**\<`T`\>(`token`, `provider`, `dependencies`, `timeouts?`): `void`

Defined in: [orchestrator.ts:180](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L180)

Register a component provider with optional explicit dependencies/timeouts.
Throws on duplicate registrations or async provider shapes.

#### Type Parameters

##### T

`T`

Token value type.

#### Parameters

##### token

[`Token`](../type-aliases/Token.md)\<`T`\>

Component token to register.

##### provider

[`Provider`](../type-aliases/Provider.md)\<`T`\>

Provider implementation (value/factory/class).

##### dependencies

readonly [`Token`](../type-aliases/Token.md)\<`unknown`\>[] = `[]`

Tokens this component depends on (topological order).

##### timeouts?

`Readonly`\<\{ `onDestroy?`: `number`; `onStart?`: `number`; `onStop?`: `number`; \}\>

Per-component timeouts (number for all phases, or per-phase object).

#### Returns

`void`

Nothing. Registers the provider into the underlying container.

#### Example

```ts
app.register(TOKEN, { useFactory: () => new MyAdapter() }, [DEP1, DEP2], { onStart: 1000 })
```

***

### start()

> **start**(`regs`): `Promise`\<`void`\>

Defined in: [orchestrator.ts:214](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L214)

Start all components in dependency order.

- Optionally provides additional registration entries to register and start in one call.
- On failure, previously started components are rolled back (stopped) in reverse order.
- Aggregates errors with code ORK1013.

#### Parameters

##### regs

readonly [`OrchestratorRegistration`](../interfaces/OrchestratorRegistration.md)\<`unknown`\>[] = `[]`

Optional registration entries to register before starting.

#### Returns

`Promise`\<`void`\>

A promise that resolves when all start jobs complete or rejects with an aggregated error.

#### Example

```ts
const app = new Orchestrator(new Container())
await app.start()
// or start with registrations
await app.start([
  register(TOKEN, { useClass: Impl }),
])
```

***

### stop()

> **stop**(): `Promise`\<`void`\>

Defined in: [orchestrator.ts:298](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L298)

Stop started components in reverse dependency order.
Aggregates ORK1014 on failure.

#### Returns

`Promise`\<`void`\>

A promise that resolves when stop completes across all components.

#### Example

```ts
const app = new Orchestrator(new Container())
await app.stop()
```

---

## Class: QueueAdapter\<T\>

[**@orkestrel/core**](../index.md)

***

# Class: QueueAdapter\<T\>

Defined in: [adapters/queue.ts:25](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/queue.ts#L25)

In-memory task queue with concurrency control, timeouts, and shared deadlines.

Provides a FIFO queue for items and a task runner that can execute tasks with configurable
concurrency limits, per-task timeouts, and shared deadlines. Supports abort signals for
cancellation and preserves result order regardless of completion timing.

## Example

```ts
import { QueueAdapter } from '@orkestrel/core'
const queue = new QueueAdapter({ concurrency: 2, timeout: 1000 })
const results = await queue.run([
  async () => { await delay(100); return 1 },
  async () => { await delay(50); return 2 },
  async () => { await delay(200); return 3 },
])
console.log(results) // => [1, 2, 3] (order preserved)
```

## Type Parameters

### T

`T` = `unknown`

## Implements

- [`QueuePort`](../interfaces/QueuePort.md)\<`T`\>

## Constructors

### Constructor

> **new QueueAdapter**\<`T`\>(`options`): `QueueAdapter`\<`T`\>

Defined in: [adapters/queue.ts:45](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/queue.ts#L45)

Construct a QueueAdapter with optional configuration defaults.

#### Parameters

##### options

[`QueueAdapterOptions`](../interfaces/QueueAdapterOptions.md) = `{}`

Configuration options for queue behavior:
- capacity: Maximum number of items the queue can hold (unlimited if not specified)
- concurrency: Default maximum number of tasks to run concurrently
- timeout: Default per-task timeout in milliseconds
- deadline: Default shared deadline in milliseconds for all tasks
- signal: Default AbortSignal for cancellation
- logger: Optional logger port for diagnostics
- diagnostic: Optional diagnostic port for telemetry

#### Returns

`QueueAdapter`\<`T`\>

## Accessors

### diagnostic

#### Get Signature

> **get** **diagnostic**(): [`DiagnosticPort`](../interfaces/DiagnosticPort.md)

Defined in: [adapters/queue.ts:69](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/queue.ts#L69)

Access the diagnostic port used by this queue adapter for telemetry and error signaling.

##### Returns

[`DiagnosticPort`](../interfaces/DiagnosticPort.md)

The configured DiagnosticPort instance

***

### logger

#### Get Signature

> **get** **logger**(): [`LoggerPort`](../interfaces/LoggerPort.md)

Defined in: [adapters/queue.ts:62](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/queue.ts#L62)

Access the logger port used by this queue adapter.

##### Returns

[`LoggerPort`](../interfaces/LoggerPort.md)

The configured LoggerPort instance

## Methods

### dequeue()

> **dequeue**(): `Promise`\<`undefined` \| `T`\>

Defined in: [adapters/queue.ts:101](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/queue.ts#L101)

Dequeue and return the next item from the queue.

#### Returns

`Promise`\<`undefined` \| `T`\>

The next item in FIFO order, or undefined if the queue is empty

#### Example

```ts
const item = await queue.dequeue()
if (item) console.log('Processing:', item)
```

#### Implementation of

[`QueuePort`](../interfaces/QueuePort.md).[`dequeue`](../interfaces/QueuePort.md#dequeue)

***

### enqueue()

> **enqueue**(`item`): `Promise`\<`void`\>

Defined in: [adapters/queue.ts:83](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/queue.ts#L83)

Enqueue a single item to the in-memory FIFO queue.

#### Parameters

##### item

`T`

The item to add to the queue

#### Returns

`Promise`\<`void`\>

void

#### Throws

Error with code ORK1050 when capacity is set and would be exceeded

#### Example

```ts
await queue.enqueue({ id: 1, data: 'task payload' })
```

#### Implementation of

[`QueuePort`](../interfaces/QueuePort.md).[`enqueue`](../interfaces/QueuePort.md#enqueue)

***

### run()

> **run**\<`R`\>(`tasks`, `options`): `Promise`\<readonly `R`[]\>

Defined in: [adapters/queue.ts:145](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/queue.ts#L145)

Run a set of tasks with optional concurrency control, timeouts, and a shared deadline.

Tasks are executed with the specified concurrency limit (defaults to unlimited). Results are
returned in the same order as the input tasks, regardless of completion timing. When both
a per-task timeout and a shared deadline are provided, the effective limit is the minimum
of the two for each task. If the shared deadline elapses or a task times out, execution
aborts with an error (ORK1052 for task timeout, ORK1053 for shared deadline exceeded).

#### Type Parameters

##### R

`R`

The return type of the tasks

#### Parameters

##### tasks

readonly () => `R` \| `Promise`\<`R`\>[]

Array of task functions (sync or async) to execute

##### options

[`QueueRunOptions`](../interfaces/QueueRunOptions.md) = `{}`

Run options (overrides constructor defaults):
- concurrency: Maximum number of tasks to run concurrently
- timeout: Per-task timeout in milliseconds
- deadline: Shared deadline in milliseconds for all tasks
- signal: AbortSignal to cancel execution

#### Returns

`Promise`\<readonly `R`[]\>

Array of task results in the same order as input tasks

#### Throws

Error with code ORK1051 when aborted, ORK1052 on task timeout, or ORK1053 on shared deadline exceeded

#### Example

```ts
const results = await queue.run([
  async () => fetchUser(1),
  async () => fetchUser(2),
  async () => fetchUser(3),
], { concurrency: 2, timeout: 5000 })
console.log('Fetched users:', results)
```

#### Implementation of

[`QueuePort`](../interfaces/QueuePort.md).[`run`](../interfaces/QueuePort.md#run)

***

### size()

> **size**(): `Promise`\<`number`\>

Defined in: [adapters/queue.ts:114](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/queue.ts#L114)

Return the current number of items in the queue.

#### Returns

`Promise`\<`number`\>

The queue size

#### Example

```ts
const currentSize = await queue.size()
console.log(`Queue has ${currentSize} items`)
```

#### Implementation of

[`QueuePort`](../interfaces/QueuePort.md).[`size`](../interfaces/QueuePort.md#size)

---

## Class: RegistryAdapter\<T\>

[**@orkestrel/core**](../index.md)

***

# Class: RegistryAdapter\<T\>

Defined in: [adapters/registry.ts:28](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/registry.ts#L28)

Named instance registry with optional default and locking support.

Provides a type-safe registry for storing and retrieving named instances. Supports both
string and symbol keys. Optionally designates a default instance that cannot be replaced.
Individual entries can be locked to prevent replacement. Commonly used by Container and
Orchestrator for managing global instances.

## Example

```ts
import { RegistryAdapter } from '@orkestrel/core'
const reg = new RegistryAdapter<number>({
  label: 'config',
  default: { value: 42 }
})
reg.set('alt', 7, true) // locked=true prevents replacement
const def = reg.resolve()        // 42
const alt = reg.resolve('alt')   // 7
reg.clear('alt')                 // false (locked)
reg.clear('alt', true)           // true (forced)
```

## Type Parameters

### T

`T`

## Implements

- [`RegistryPort`](../interfaces/RegistryPort.md)\<`T`\>

## Constructors

### Constructor

> **new RegistryAdapter**\<`T`\>(`options`): `RegistryAdapter`\<`T`\>

Defined in: [adapters/registry.ts:46](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/registry.ts#L46)

Construct a RegistryAdapter with optional label and default instance.

#### Parameters

##### options

[`RegistryAdapterOptions`](../interfaces/RegistryAdapterOptions.md)\<`T`\> = `{}`

Configuration options:
- label: Human-readable label used in error messages (default: 'registry')
- default: Optional default entry with value and optional key.
- logger: Optional logger port for diagnostics
- diagnostic: Optional diagnostic port for error reporting

#### Returns

`RegistryAdapter`\<`T`\>

## Accessors

### diagnostic

#### Get Signature

> **get** **diagnostic**(): [`DiagnosticPort`](../interfaces/DiagnosticPort.md)

Defined in: [adapters/registry.ts:68](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/registry.ts#L68)

Access the diagnostic port used by this registry for error reporting.

##### Returns

[`DiagnosticPort`](../interfaces/DiagnosticPort.md)

The configured DiagnosticPort instance

***

### logger

#### Get Signature

> **get** **logger**(): [`LoggerPort`](../interfaces/LoggerPort.md)

Defined in: [adapters/registry.ts:61](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/registry.ts#L61)

Access the logger port used by this registry.

##### Returns

[`LoggerPort`](../interfaces/LoggerPort.md)

The configured LoggerPort instance

## Methods

### clear()

> **clear**(`name?`, `force?`): `boolean`

Defined in: [adapters/registry.ts:157](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/registry.ts#L157)

Clear a named instance from the registry.

The default instance is always protected and cannot be cleared. Locked instances
cannot be cleared unless force=true.

#### Parameters

##### name?

String or symbol key; when omitted, attempts to clear the default (always fails)

`string` | `symbol`

##### force?

`boolean` = `false`

When true, allows clearing a locked instance (default: false)

#### Returns

`boolean`

True if the instance was removed, false otherwise

#### Example

```ts
reg.clear('staging')           // removes if not locked
reg.clear('prod')              // false if locked
reg.clear('prod', true)        // true (forced removal)
```

#### Implementation of

[`RegistryPort`](../interfaces/RegistryPort.md).[`clear`](../interfaces/RegistryPort.md#clear)

***

### get()

> **get**(`name?`): `undefined` \| `T`

Defined in: [adapters/registry.ts:82](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/registry.ts#L82)

Get a named value without throwing an error.

#### Parameters

##### name?

String or symbol key; when omitted, the default key is used

`string` | `symbol`

#### Returns

`undefined` \| `T`

The registered value, or undefined if not found

#### Example

```ts
const value = reg.get('myKey')
if (value) console.log('Found:', value)
```

#### Implementation of

[`RegistryPort`](../interfaces/RegistryPort.md).[`get`](../interfaces/RegistryPort.md#get)

***

### list()

> **list**(): readonly (`string` \| `symbol`)[]

Defined in: [adapters/registry.ts:178](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/registry.ts#L178)

List all registered keys (including the default key symbol when present).

#### Returns

readonly (`string` \| `symbol`)[]

A read-only array of all registered keys (strings and symbols)

#### Example

```ts
const keys = reg.list()
console.log('Registered keys:', keys)
```

#### Implementation of

[`RegistryPort`](../interfaces/RegistryPort.md).[`list`](../interfaces/RegistryPort.md#list)

***

### resolve()

> **resolve**(`name?`): `T`

Defined in: [adapters/registry.ts:101](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/registry.ts#L101)

Resolve a named value, throwing an error if not found.

#### Parameters

##### name?

String or symbol key; when omitted, resolves the default key

`string` | `symbol`

#### Returns

`T`

The registered value

#### Throws

Error with code ORK1001 if no default is registered when name is omitted

#### Throws

Error with code ORK1002 if the named instance is not found

#### Example

```ts
const value = reg.resolve('myKey') // throws if not found
const defaultValue = reg.resolve() // throws if no default
```

#### Implementation of

[`RegistryPort`](../interfaces/RegistryPort.md).[`resolve`](../interfaces/RegistryPort.md#resolve)

***

### set()

> **set**(`name`, `value`, `lock`): `void`

Defined in: [adapters/registry.ts:129](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/adapters/registry.ts#L129)

Register or replace a named instance in the registry.

#### Parameters

##### name

String or symbol key for the instance

`string` | `symbol`

##### value

`T`

The instance to store

##### lock

`boolean` = `false`

When true, prevents further replacement for this key (default: false)

#### Returns

`void`

void

#### Throws

Error with code ORK1003 if attempting to replace the default instance

#### Throws

Error with code ORK1004 if attempting to replace a locked instance

#### Example

```ts
reg.set('prod', prodConfig)
reg.set('prod', newConfig, true) // locked=true prevents future replacement
```

#### Implementation of

[`RegistryPort`](../interfaces/RegistryPort.md).[`set`](../interfaces/RegistryPort.md#set)

---

## Function: arrayOf()

[**@orkestrel/core**](../index.md)

***

# Function: arrayOf()

> **arrayOf**\<`T`\>(`elem`): [`Guard`](../type-aliases/Guard.md)\<readonly `T`[]\>

Defined in: [helpers.ts:102](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L102)

Build a guard for arrays whose elements satisfy a provided element guard.

## Type Parameters

### T

`T`

Element type produced by the element guard

## Parameters

### elem

[`Guard`](../type-aliases/Guard.md)\<`T`\>

Guard function to validate each array element

## Returns

[`Guard`](../type-aliases/Guard.md)\<readonly `T`[]\>

Guard that checks an array whose elements satisfy elem

## Example

```ts
const isStringArray = arrayOf(isString)
isStringArray(['a','b']) // true
isStringArray(['a', 1]) // false
```

---

## Function: createPortToken()

[**@orkestrel/core**](../index.md)

***

# Function: createPortToken()

> **createPortToken**\<`T`\>(`name`): [`Token`](../type-aliases/Token.md)\<`T`\>

Defined in: [ports.ts:81](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/ports.ts#L81)

Create a single Port token with a stable description under the `ports:` namespace.

## Type Parameters

### T

`T`

## Parameters

### name

`string`

Port name appended to the 'ports:' namespace for Symbol description.

## Returns

[`Token`](../type-aliases/Token.md)\<`T`\>

A Token<T> describing the named port.

## Example

```ts
const HttpPort = createPortToken<{ get(url: string): Promise<string> }>('http')
// container.set(HttpPort, impl)
```

---

## Function: createPortTokens()

[**@orkestrel/core**](../index.md)

***

# Function: createPortTokens()

> **createPortTokens**\<`T`\>(`shape`, `namespace`): [`TokensOf`](../type-aliases/TokensOf.md)\<`T`\>

Defined in: [ports.ts:27](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/ports.ts#L27)

Create a read-only set of Port tokens from a shape object.

Each key in the provided shape becomes a token in the returned object, and the value's TypeScript type
is used as the token's generic type parameter.

## Type Parameters

### T

`T` *extends* `Record`\<`string`, `unknown`\>

## Parameters

### shape

`T`

Object whose keys are port names and values define the token types via their TypeScript shape.

### namespace

`string` = `'ports'`

Optional namespace prefix used in token descriptions (default: 'ports').

## Returns

[`TokensOf`](../type-aliases/TokensOf.md)\<`T`\>

A frozen map of tokens keyed by the provided shape's keys.

## See

extendPorts

## Example

```ts
import { createPortTokens, Container } from '@orkestrel/core'
const ports = createPortTokens({ logger: undefined as { info(msg: string): void } })
const c = new Container()
c.set(ports.logger, { info: console.log })
c.resolve(ports.logger).info('hello')
```

---

## Function: createToken()

[**@orkestrel/core**](../index.md)

***

# Function: createToken()

> **createToken**\<`_T`\>(`description`): [`Token`](../type-aliases/Token.md)\<`_T`\>

Defined in: [helpers.ts:197](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L197)

## Type Parameters

### _T

`_T` = `unknown`

The value type carried by the token (typing only)

## Parameters

### description

`string`

Symbol description used in diagnostics

## Returns

[`Token`](../type-aliases/Token.md)\<`_T`\>

A new unique symbol token

---

## Function: createTokens()

[**@orkestrel/core**](../index.md)

***

# Function: createTokens()

> **createTokens**\<`T`\>(`namespace`, `shape`): `Readonly`\<`{ [K in keyof T & string]: Token<T[K]> }`\>

Defined in: [helpers.ts:227](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L227)

Create a set of tokens from a shape under a given namespace.

## Type Parameters

### T

`T` *extends* `Record`\<`string`, `unknown`\>

Shape whose property types become the token types

## Parameters

### namespace

`string`

Description prefix for token symbols (e.g., 'ports')

### shape

`T`

Object whose keys become token names and types define token value types

## Returns

`Readonly`\<`{ [K in keyof T & string]: Token<T[K]> }`\>

Frozen map of tokens keyed by the shape's keys

## Example

```ts
const tokens = createTokens('services', { a: 0 as number, b: '' as string })
```

---

## Function: extendPorts()

[**@orkestrel/core**](../index.md)

***

# Function: extendPorts()

Extend an existing token map or create a new one from a shape.

- extendPorts(ext) creates a new token set from scratch.
- extendPorts(base, ext) merges into an existing token map (throws on duplicate keys).

## Param

Either just the extension shape, or a base map and extension shape

## Throws

Error with code ORK1040 when duplicate keys are present in the extension shape

## Example

```ts
const base = createPortTokens({ a: undefined as number })
const more = extendPorts(base, { b: undefined as string })
// more.a and more.b are tokens
```

## Call Signature

> **extendPorts**\<`Ext`\>(`ext`): `Readonly`\<[`TokensOf`](../type-aliases/TokensOf.md)\<`Ext`\>\>

Defined in: [ports.ts:32](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/ports.ts#L32)

Extend an existing set of Port tokens with additional ports or create a new one (overload).

### Type Parameters

#### Ext

`Ext` *extends* `Record`\<`string`, `unknown`\>

### Parameters

#### ext

`Ext`

### Returns

`Readonly`\<[`TokensOf`](../type-aliases/TokensOf.md)\<`Ext`\>\>

## Call Signature

> **extendPorts**\<`Base`, `Ext`\>(`base`, `ext`): `Readonly`\<`Base` & [`TokensOf`](../type-aliases/TokensOf.md)\<`Ext`\>\>

Defined in: [ports.ts:34](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/ports.ts#L34)

Extend a base token map with an extension shape (overload).

### Type Parameters

#### Base

`Base` *extends* `Record`\<`string`, [`Token`](../type-aliases/Token.md)\<`unknown`\>\>

#### Ext

`Ext` *extends* `Record`\<`string`, `unknown`\>

### Parameters

#### base

`Base`

#### ext

`Ext`

### Returns

`Readonly`\<`Base` & [`TokensOf`](../type-aliases/TokensOf.md)\<`Ext`\>\>

---

## Function: getTag()

[**@orkestrel/core**](../index.md)

***

# Function: getTag()

> **getTag**(`x`): `string`

Defined in: [helpers.ts:499](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L499)

Return the internal [[Class]] tag string for a value.

## Parameters

### x

`unknown`

Value to inspect

## Returns

`string`

Tag like "[object Array]" or "[object Date]"

## Example

```ts
getTag([]) // "[object Array]"
```

---

## Function: hasOwn()

[**@orkestrel/core**](../index.md)

***

# Function: hasOwn()

## Call Signature

> **hasOwn**\<`K`\>(`obj`, `key`): `obj is Record<K, unknown>`

Defined in: [helpers.ts:146](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L146)

Narrow an unknown to an object that owns the given key(s) (non-prototype).

Overloads preserve the original type when known.

### Type Parameters

#### K

`K` *extends* `PropertyKey`

### Parameters

#### obj

`unknown`

Value to check

#### key

`K`

One or more keys to require on the object

### Returns

`obj is Record<K, unknown>`

True when obj is an object and owns all keys

### Example

```ts
if (hasOwn(x, 'id', 'name')) {
  // x: Record<'id' | 'name', unknown>
}
```

## Call Signature

> **hasOwn**\<`Ks`\>(`obj`, ...`keys`): `obj is { [P in PropertyKey]: unknown }`

Defined in: [helpers.ts:148](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L148)

Narrow an unknown to an object that owns the given key(s) (non-prototype).

Overloads preserve the original type when known.

### Type Parameters

#### Ks

`Ks` *extends* readonly `PropertyKey`[]

### Parameters

#### obj

`unknown`

Value to check

#### keys

...`Ks`

### Returns

`obj is { [P in PropertyKey]: unknown }`

True when obj is an object and owns all keys

### Example

```ts
if (hasOwn(x, 'id', 'name')) {
  // x: Record<'id' | 'name', unknown>
}
```

## Call Signature

> **hasOwn**\<`T`, `K`\>(`obj`, `key`): `obj is T & Record<K, unknown>`

Defined in: [helpers.ts:150](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L150)

Narrow an unknown to an object that owns the given key(s) (non-prototype).

Overloads preserve the original type when known.

### Type Parameters

#### T

`T` *extends* `object`

#### K

`K` *extends* `PropertyKey`

### Parameters

#### obj

`T`

Value to check

#### key

`K`

One or more keys to require on the object

### Returns

`obj is T & Record<K, unknown>`

True when obj is an object and owns all keys

### Example

```ts
if (hasOwn(x, 'id', 'name')) {
  // x: Record<'id' | 'name', unknown>
}
```

## Call Signature

> **hasOwn**\<`T`, `Ks`\>(`obj`, ...`keys`): `obj is T & { [P in PropertyKey]: unknown }`

Defined in: [helpers.ts:152](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L152)

Narrow an unknown to an object that owns the given key(s) (non-prototype).

Overloads preserve the original type when known.

### Type Parameters

#### T

`T` *extends* `object`

#### Ks

`Ks` *extends* readonly `PropertyKey`[]

### Parameters

#### obj

`T`

Value to check

#### keys

...`Ks`

### Returns

`obj is T & { [P in PropertyKey]: unknown }`

True when obj is an object and owns all keys

### Example

```ts
if (hasOwn(x, 'id', 'name')) {
  // x: Record<'id' | 'name', unknown>
}
```

---

## Function: hasSchema()

[**@orkestrel/core**](../index.md)

***

# Function: hasSchema()

> **hasSchema**\<`S`\>(`obj`, `schema`): `obj is FromSchema<S>`

Defined in: [helpers.ts:173](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L173)

Check that a value matches an object schema at runtime, with static inference.

## Type Parameters

### S

`S` *extends* `Readonly`\<\{\[`k`: `string`\]: Readonly\<\{ \[k: string\]: Readonly\<...\> \| PrimitiveTag \| Guard\<unknown\>; \}\> \| [`PrimitiveTag`](../type-aliases/PrimitiveTag.md) \| [`Guard`](../type-aliases/Guard.md)\<`unknown`\>; \}\>

The schema specification type

## Parameters

### obj

`unknown`

Value to validate

### schema

`S`

Object schema defining required keys and types/guards

## Returns

`obj is FromSchema<S>`

True when the value satisfies the schema

## Example

```ts
const userSchema = { id: 'string', age: 'number' } as const
if (hasSchema(x, userSchema)) console.log(x.id, x.age)
```

---

## Function: isAggregateLifecycleError()

[**@orkestrel/core**](../index.md)

***

# Function: isAggregateLifecycleError()

> **isAggregateLifecycleError**(`x`): `x is AggregateLifecycleError`

Defined in: [helpers.ts:653](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L653)

Guard for aggregate lifecycle error shape used by DiagnosticAdapter.aggregate.

## Parameters

### x

`unknown`

Value to validate

## Returns

`x is AggregateLifecycleError`

True if x has details and errors arrays

## Example

```ts
const agg = { details: [], errors: [] }
isAggregateLifecycleError(agg) // true
```

---

## Function: isAsyncFunction()

[**@orkestrel/core**](../index.md)

***

# Function: isAsyncFunction()

> **isAsyncFunction**(`fn`): `fn is (args: unknown[]) => Promise<unknown>`

Defined in: [helpers.ts:514](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L514)

Heuristic check for an async function (native or transpiled).

## Parameters

### fn

`unknown`

Value to check

## Returns

`fn is (args: unknown[]) => Promise<unknown>`

True if fn appears to be an async function

## Example

```ts
isAsyncFunction(async () => {}) // true
```

---

## Function: isBoolean()

[**@orkestrel/core**](../index.md)

***

# Function: isBoolean()

> **isBoolean**(`x`): `x is boolean`

Defined in: [helpers.ts:68](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L68)

Check whether a value is a boolean primitive.

## Parameters

### x

`unknown`

Value to check

## Returns

`x is boolean`

True if x is a boolean, false otherwise

## Example

```ts
isBoolean(true) // true
isBoolean(0) // false
```

---

## Function: isClassProvider()

[**@orkestrel/core**](../index.md)

***

# Function: isClassProvider()

> **isClassProvider**\<`T`\>(`p`): `p is ClassProvider<T>`

Defined in: [helpers.ts:329](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L329)

Check if provider has a ClassProvider shape (`{ useClass }`).

## Type Parameters

### T

`T`

Provider value type

## Parameters

### p

[`Provider`](../type-aliases/Provider.md)\<`T`\>

Provider to check

## Returns

`p is ClassProvider<T>`

True if p is ClassProvider

## Example

```ts
class S {}
isClassProvider({ useClass: S }) // true
```

---

## Function: isClassProviderNoDeps()

[**@orkestrel/core**](../index.md)

***

# Function: isClassProviderNoDeps()

> **isClassProviderNoDeps**\<`T`\>(`p`): `p is ClassProviderNoDeps<T>`

Defined in: [helpers.ts:398](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L398)

Check if class provider has no dependencies (zero-arg constructor).

## Type Parameters

### T

`T`

Provider value type

## Parameters

### p

[`ClassProvider`](../type-aliases/ClassProvider.md)\<`T`\>

ClassProvider to check

## Returns

`p is ClassProviderNoDeps<T>`

True if zero-arg constructor (and no explicit inject)

## Example

```ts
class S { constructor() {} }
isClassProviderNoDeps<number>({ useClass: S } as any)
```

---

## Function: isClassProviderWithContainer()

[**@orkestrel/core**](../index.md)

***

# Function: isClassProviderWithContainer()

> **isClassProviderWithContainer**\<`T`\>(`p`): `p is ClassProviderWithContainer<T>`

Defined in: [helpers.ts:381](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L381)

Check if class provider receives Container as constructor argument.

## Type Parameters

### T

`T`

Provider value type

## Parameters

### p

[`ClassProvider`](../type-aliases/ClassProvider.md)\<`T`\>

ClassProvider to check

## Returns

`p is ClassProviderWithContainer<T>`

True if constructor takes Container (and no explicit inject)

## Example

```ts
class S { constructor(_c: Container) {} }
isClassProviderWithContainer<number>({ useClass: S } as any)
```

---

## Function: isClassProviderWithObject()

[**@orkestrel/core**](../index.md)

***

# Function: isClassProviderWithObject()

> **isClassProviderWithObject**\<`T`\>(`p`): `p is ClassProviderWithObject<T, Record<string, unknown>>`

Defined in: [helpers.ts:364](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L364)

Check if class provider uses object injection (inject: `{ a: A, b: B }`).

## Type Parameters

### T

`T`

Provider value type

## Parameters

### p

Provider to check

`T` | [`ValueProvider`](../interfaces/ValueProvider.md)\<`T`\> | [`FactoryProviderNoDeps`](../type-aliases/FactoryProviderNoDeps.md)\<`T`\> | [`FactoryProviderWithContainer`](../type-aliases/FactoryProviderWithContainer.md)\<`T`\> | [`FactoryProviderWithTuple`](../type-aliases/FactoryProviderWithTuple.md)\<`T`, readonly `unknown`[]\> | [`FactoryProviderWithObject`](../type-aliases/FactoryProviderWithObject.md)\<`T`, `Record`\<`string`, `unknown`\>\> | [`ClassProviderNoDeps`](../type-aliases/ClassProviderNoDeps.md)\<`T`\> | [`ClassProviderWithContainer`](../type-aliases/ClassProviderWithContainer.md)\<`T`\> | [`ClassProviderWithTuple`](../type-aliases/ClassProviderWithTuple.md)\<`T`, readonly `unknown`[]\> | [`ClassProviderWithObject`](../type-aliases/ClassProviderWithObject.md)\<`T`, `Record`\<`string`, `unknown`\>\>

## Returns

`p is ClassProviderWithObject<T, Record<string, unknown>>`

True if object-injected ClassProvider

## Example

```ts
class S { constructor(_deps: { a: number, b: string }) {} }
isClassProviderWithObject<number>({ useClass: S, inject: { a: Symbol('A'), b: Symbol('B') } } as any)
```

---

## Function: isClassProviderWithTuple()

[**@orkestrel/core**](../index.md)

***

# Function: isClassProviderWithTuple()

> **isClassProviderWithTuple**\<`T`, `A`\>(`p`): `p is ClassProviderWithTuple<T, A>`

Defined in: [helpers.ts:347](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L347)

Check if class provider uses tuple injection (inject: `[A, B, ...]`).

## Type Parameters

### T

`T`

Provider value type

### A

`A` *extends* readonly `unknown`[]

Tuple type of injected dependencies

## Parameters

### p

Provider to check

`T` | [`ValueProvider`](../interfaces/ValueProvider.md)\<`T`\> | [`FactoryProviderNoDeps`](../type-aliases/FactoryProviderNoDeps.md)\<`T`\> | [`FactoryProviderWithContainer`](../type-aliases/FactoryProviderWithContainer.md)\<`T`\> | [`FactoryProviderWithTuple`](../type-aliases/FactoryProviderWithTuple.md)\<`T`, readonly `unknown`[]\> | [`FactoryProviderWithObject`](../type-aliases/FactoryProviderWithObject.md)\<`T`, `Record`\<`string`, `unknown`\>\> | [`ClassProviderNoDeps`](../type-aliases/ClassProviderNoDeps.md)\<`T`\> | [`ClassProviderWithContainer`](../type-aliases/ClassProviderWithContainer.md)\<`T`\> | [`ClassProviderWithTuple`](../type-aliases/ClassProviderWithTuple.md)\<`T`, readonly `unknown`[]\> | [`ClassProviderWithObject`](../type-aliases/ClassProviderWithObject.md)\<`T`, `Record`\<`string`, `unknown`\>\>

## Returns

`p is ClassProviderWithTuple<T, A>`

True if tuple-injected ClassProvider

## Example

```ts
class S { constructor(_a: number, _b: string) {} }
isClassProviderWithTuple<number, readonly [number, string]>({ useClass: S, inject: [Symbol('A'), Symbol('B')] })
```

---

## Function: isFactoryProvider()

[**@orkestrel/core**](../index.md)

***

# Function: isFactoryProvider()

> **isFactoryProvider**\<`T`\>(`p`): `p is FactoryProvider<T>`

Defined in: [helpers.ts:312](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L312)

Check if provider has a FactoryProvider shape (`{ useFactory }`).

## Type Parameters

### T

`T`

Provider value type

## Parameters

### p

[`Provider`](../type-aliases/Provider.md)\<`T`\>

Provider to check

## Returns

`p is FactoryProvider<T>`

True if p is FactoryProvider

## Example

```ts
isFactoryProvider({ useFactory: () => 1 }) // true
```

---

## Function: isFactoryProviderNoDeps()

[**@orkestrel/core**](../index.md)

***

# Function: isFactoryProviderNoDeps()

> **isFactoryProviderNoDeps**\<`T`\>(`p`): `p is FactoryProviderNoDeps<T>`

Defined in: [helpers.ts:467](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L467)

Check if factory provider has no dependencies (zero-arg function).

## Type Parameters

### T

`T`

Provider value type

## Parameters

### p

[`FactoryProvider`](../type-aliases/FactoryProvider.md)\<`T`\>

FactoryProvider to check

## Returns

`p is FactoryProviderNoDeps<T>`

True if zero-arg factory (and no explicit inject)

## Example

```ts
const fp: FactoryProviderNoDeps<number> = { useFactory: () => 1 }
isZeroArg(fp.useFactory) // true
```

---

## Function: isFactoryProviderWithContainer()

[**@orkestrel/core**](../index.md)

***

# Function: isFactoryProviderWithContainer()

> **isFactoryProviderWithContainer**\<`T`\>(`p`): `p is FactoryProviderWithContainer<T>`

Defined in: [helpers.ts:450](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L450)

Check if factory provider receives Container as function argument.

## Type Parameters

### T

`T`

Provider value type

## Parameters

### p

[`FactoryProvider`](../type-aliases/FactoryProvider.md)\<`T`\>

FactoryProvider to check

## Returns

`p is FactoryProviderWithContainer<T>`

True if factory takes Container (and no explicit inject)

## Example

```ts
const p = { useFactory: (c: Container) => 1 }
isFactoryProviderWithContainer<number>(p as any)
```

---

## Function: isFactoryProviderWithObject()

[**@orkestrel/core**](../index.md)

***

# Function: isFactoryProviderWithObject()

> **isFactoryProviderWithObject**\<`T`\>(`p`): `p is FactoryProviderWithObject<T, Record<string, unknown>>`

Defined in: [helpers.ts:433](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L433)

Check if factory provider uses object injection (inject: `{ a: A, b: B }`).

## Type Parameters

### T

`T`

Provider value type

## Parameters

### p

Provider to check

`T` | [`ValueProvider`](../interfaces/ValueProvider.md)\<`T`\> | [`FactoryProviderNoDeps`](../type-aliases/FactoryProviderNoDeps.md)\<`T`\> | [`FactoryProviderWithContainer`](../type-aliases/FactoryProviderWithContainer.md)\<`T`\> | [`FactoryProviderWithTuple`](../type-aliases/FactoryProviderWithTuple.md)\<`T`, readonly `unknown`[]\> | [`FactoryProviderWithObject`](../type-aliases/FactoryProviderWithObject.md)\<`T`, `Record`\<`string`, `unknown`\>\> | [`ClassProviderNoDeps`](../type-aliases/ClassProviderNoDeps.md)\<`T`\> | [`ClassProviderWithContainer`](../type-aliases/ClassProviderWithContainer.md)\<`T`\> | [`ClassProviderWithTuple`](../type-aliases/ClassProviderWithTuple.md)\<`T`, readonly `unknown`[]\> | [`ClassProviderWithObject`](../type-aliases/ClassProviderWithObject.md)\<`T`, `Record`\<`string`, `unknown`\>\>

## Returns

`p is FactoryProviderWithObject<T, Record<string, unknown>>`

True if object-injected FactoryProvider

## Example

```ts
const p = { useFactory: (d: { a: number, b: string }) => d.a + d.b.length, inject: { a: Symbol('A'), b: Symbol('B') } }
isFactoryProviderWithObject<number>(p as any)
```

---

## Function: isFactoryProviderWithTuple()

[**@orkestrel/core**](../index.md)

***

# Function: isFactoryProviderWithTuple()

> **isFactoryProviderWithTuple**\<`T`, `A`\>(`p`): `p is FactoryProviderWithTuple<T, A>`

Defined in: [helpers.ts:416](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L416)

Check if factory provider uses tuple injection (inject: `[A, B, ...]`).

## Type Parameters

### T

`T`

Provider value type

### A

`A` *extends* readonly `unknown`[]

Tuple type of injected dependencies

## Parameters

### p

Provider to check

`T` | [`ValueProvider`](../interfaces/ValueProvider.md)\<`T`\> | [`FactoryProviderNoDeps`](../type-aliases/FactoryProviderNoDeps.md)\<`T`\> | [`FactoryProviderWithContainer`](../type-aliases/FactoryProviderWithContainer.md)\<`T`\> | [`FactoryProviderWithTuple`](../type-aliases/FactoryProviderWithTuple.md)\<`T`, readonly `unknown`[]\> | [`FactoryProviderWithObject`](../type-aliases/FactoryProviderWithObject.md)\<`T`, `Record`\<`string`, `unknown`\>\> | [`ClassProviderNoDeps`](../type-aliases/ClassProviderNoDeps.md)\<`T`\> | [`ClassProviderWithContainer`](../type-aliases/ClassProviderWithContainer.md)\<`T`\> | [`ClassProviderWithTuple`](../type-aliases/ClassProviderWithTuple.md)\<`T`, readonly `unknown`[]\> | [`ClassProviderWithObject`](../type-aliases/ClassProviderWithObject.md)\<`T`, `Record`\<`string`, `unknown`\>\>

## Returns

`p is FactoryProviderWithTuple<T, A>`

True if tuple-injected FactoryProvider

## Example

```ts
const p = { useFactory: (a: number, b: string) => a + b.length, inject: [Symbol('A'), Symbol('B')] }
isFactoryProviderWithTuple<number, readonly [number, string]>(p as any)
```

---

## Function: isFiniteNumber()

[**@orkestrel/core**](../index.md)

***

# Function: isFiniteNumber()

> **isFiniteNumber**(`x`): `x is number`

Defined in: [helpers.ts:84](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L84)

Check whether a value is a finite number (excludes NaN and Infinity).

## Parameters

### x

`unknown`

Value to check

## Returns

`x is number`

True if x is a finite number, false otherwise

## Example

```ts
isFiniteNumber(42) // true
isFiniteNumber(NaN) // false
```

---

## Function: isLifecycleErrorDetail()

[**@orkestrel/core**](../index.md)

***

# Function: isLifecycleErrorDetail()

> **isLifecycleErrorDetail**(`x`): x is \{ context: "normal" \| "rollback" \| "container"; durationMs: number; error: Error; phase: "start" \| "stop" \| "destroy"; timedOut: boolean; tokenDescription: string \}

Defined in: [helpers.ts:591](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L591)

Runtime guard for LifecycleErrorDetail using a schema definition.

## Parameters

### x

`unknown`

Value to validate

## Returns

x is \{ context: "normal" \| "rollback" \| "container"; durationMs: number; error: Error; phase: "start" \| "stop" \| "destroy"; timedOut: boolean; tokenDescription: string \}

True if x matches the expected shape

## Example

```ts
const detail = { tokenDescription: 'A', phase: 'start', context: 'normal', timedOut: false, durationMs: 1, error: new Error('x') }
isLifecycleErrorDetail(detail) // true
```

---

## Function: isObject()

[**@orkestrel/core**](../index.md)

***

# Function: isObject()

> **isObject**(`x`): `x is Record<string, unknown>`

Defined in: [helpers.ts:36](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L36)

Check whether a value is a non-null object (arrays included).

## Parameters

### x

`unknown`

Value to check

## Returns

`x is Record<string, unknown>`

True if x is a non-null object (including arrays), false otherwise

## Example

```ts
isObject({}) // true
isObject([]) // true
isObject(null) // false
```

---

## Function: isPromiseLike()

[**@orkestrel/core**](../index.md)

***

# Function: isPromiseLike()

> **isPromiseLike**\<`T`\>(`x`): `x is PromiseLike<T>`

Defined in: [helpers.ts:534](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L534)

Narrow a value to Promise-like (duck-typed thenable).

## Type Parameters

### T

`T` = `unknown`

Promised value type

## Parameters

### x

`unknown`

Value to check

## Returns

`x is PromiseLike<T>`

True if x has a callable then method

## Example

```ts
isPromiseLike(Promise.resolve(1)) // true
```

---

## Function: isProviderObject()

[**@orkestrel/core**](../index.md)

***

# Function: isProviderObject()

> **isProviderObject**(`x`): x is Readonly\<Record\<string, unknown\>\> & (\{ useValue: unknown \} \| \{ useFactory: unknown \} \| \{ useClass: unknown \})

Defined in: [helpers.ts:621](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L621)

Check if a value looks like a provider object (has `useValue`/`useFactory`/`useClass`).

## Parameters

### x

`unknown`

Value to check

## Returns

x is Readonly\<Record\<string, unknown\>\> & (\{ useValue: unknown \} \| \{ useFactory: unknown \} \| \{ useClass: unknown \})

True if x has at least one provider key

## Example

```ts
isProviderObject({ useValue: 1 }) // true
```

---

## Function: isRawProviderValue()

[**@orkestrel/core**](../index.md)

***

# Function: isRawProviderValue()

> **isRawProviderValue**\<`T`\>(`p`): `p is T`

Defined in: [helpers.ts:637](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L637)

Check if provider input is a raw value (not a provider object).

## Type Parameters

### T

`T`

Provider value type

## Parameters

### p

[`Provider`](../type-aliases/Provider.md)\<`T`\>

Provider to check

## Returns

`p is T`

True if p is not a provider object

## Example

```ts
isRawProviderValue(42) // true
```

---

## Function: isString()

[**@orkestrel/core**](../index.md)

***

# Function: isString()

> **isString**(`x`): `x is string`

Defined in: [helpers.ts:52](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L52)

Check whether a value is a string primitive.

## Parameters

### x

`unknown`

Value to check

## Returns

`x is string`

True if x is a string, false otherwise

## Example

```ts
isString('hello') // true
isString(123) // false
```

---

## Function: isToken()

[**@orkestrel/core**](../index.md)

***

# Function: isToken()

> **isToken**(`x`): `x is Token<unknown>`

Defined in: [helpers.ts:245](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L245)

Runtime check that a value is a Token (Symbol).

## Parameters

### x

`unknown`

Value to check

## Returns

`x is Token<unknown>`

True if x is a symbol

## Example

```ts
isToken(Symbol('x')) // true
```

---

## Function: isTokenArray()

[**@orkestrel/core**](../index.md)

***

# Function: isTokenArray()

> **isTokenArray**(`x`): `x is readonly Token<unknown>[]`

Defined in: [helpers.ts:260](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L260)

Guard for arrays of tokens.

## Parameters

### x

`unknown`

Value to check

## Returns

`x is readonly Token<unknown>[]`

True if x is an array of symbols

## Example

```ts
isTokenArray([Symbol('a'), Symbol('b')]) // true
```

---

## Function: isTokenRecord()

[**@orkestrel/core**](../index.md)

***

# Function: isTokenRecord()

> **isTokenRecord**(`x`): `x is Record<string, Token<unknown>>`

Defined in: [helpers.ts:275](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L275)

Guard that checks an object is a map whose values are all tokens.

## Parameters

### x

`unknown`

Value to check

## Returns

`x is Record<string, Token<unknown>>`

True if x is an object (not array) with token values

## Example

```ts
isTokenRecord({ a: Symbol('a') }) // true
```

---

## Function: isValueProvider()

[**@orkestrel/core**](../index.md)

***

# Function: isValueProvider()

> **isValueProvider**\<`T`\>(`p`): `p is ValueProvider<T>`

Defined in: [helpers.ts:296](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L296)

Check if provider has a ValueProvider shape (`{ useValue }`).

## Type Parameters

### T

`T`

Provider value type

## Parameters

### p

[`Provider`](../type-aliases/Provider.md)\<`T`\>

Provider to check

## Returns

`p is ValueProvider<T>`

True if p is ValueProvider

## Example

```ts
isValueProvider({ useValue: 42 }) // true
```

---

## Function: isZeroArg()

[**@orkestrel/core**](../index.md)

***

# Function: isZeroArg()

> **isZeroArg**\<`T`\>(`fn`): `fn is () => T`

Defined in: [helpers.ts:484](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L484)

Check if a function type accepts zero arguments.

## Type Parameters

### T

`T`

Function return type

## Parameters

### fn

() => `T`

Function to check

## Returns

`fn is () => T`

True if fn.length is 0

## Example

```ts
const f = () => 42
isZeroArg(f) // true
```

---

## Function: literalOf()

[**@orkestrel/core**](../index.md)

***

# Function: literalOf()

> **literalOf**\<`Literals`\>(...`literals`): [`Guard`](../type-aliases/Guard.md)\<`Literals`\[`number`\]\>

Defined in: [helpers.ts:120](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L120)

Build a guard for a literal union by value equality.

## Type Parameters

### Literals

`Literals` *extends* readonly (`string` \| `number` \| `boolean`)[]

Tuple of literal values

## Parameters

### literals

...`Literals`

Values that are considered valid

## Returns

[`Guard`](../type-aliases/Guard.md)\<`Literals`\[`number`\]\>

Guard that matches when x equals one of the literals

## Example

```ts
const isEnv = literalOf('dev', 'prod' as const)
isEnv('dev') // true
isEnv('staging') // false
```

---

## Function: matchProvider()

[**@orkestrel/core**](../index.md)

***

# Function: matchProvider()

## Call Signature

> **matchProvider**\<`T`\>(`provider`, `h`): [`Provider`](../type-aliases/Provider.md)\<`T`\>

Defined in: [helpers.ts:695](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L695)

Match a provider against its specific shape and dispatch to typed handlers.

### Type Parameters

#### T

`T`

Value type produced by the provider

### Parameters

#### provider

[`Provider`](../type-aliases/Provider.md)\<`T`\>

Provider input (raw value or provider object)

#### h

[`ProviderMatchHandlers`](../type-aliases/ProviderMatchHandlers.md)\<`T`\>

Handlers for each supported provider shape

### Returns

[`Provider`](../type-aliases/Provider.md)\<`T`\>

When handlers return Provider<T>, the normalized Provider<T>; otherwise the custom type R

### Remarks

Recognized shapes (checked in order):
1. raw value (not an object provider)
2. value provider: `{ useValue }`
3. factory providers: tuple | object | container | noDeps
4. class providers: tuple | object | container | noDeps

### Throws

Error with code ORK1099 when the provider shape is unknown (internal invariant)

### Example

```ts
const out = matchProvider(42, {
  raw: v => ({ useValue: v }),
  value: p => p,
  factoryTuple: p => p,
  factoryObject: p => p,
  factoryContainer: p => p,
  factoryNoDeps: p => p,
  classTuple: p => p,
  classObject: p => p,
  classContainer: p => p,
  classNoDeps: p => p,
})
```

## Call Signature

> **matchProvider**\<`T`, `R`\>(`provider`, `h`): `R`

Defined in: [helpers.ts:696](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L696)

Match a provider against its specific shape and dispatch to typed handlers.

### Type Parameters

#### T

`T`

Value type produced by the provider

#### R

`R`

Return type when using return handlers (inferred)

### Parameters

#### provider

[`Provider`](../type-aliases/Provider.md)\<`T`\>

Provider input (raw value or provider object)

#### h

[`ProviderMatchReturnHandlers`](../type-aliases/ProviderMatchReturnHandlers.md)\<`T`, `R`\>

Handlers for each supported provider shape

### Returns

`R`

When handlers return Provider<T>, the normalized Provider<T>; otherwise the custom type R

### Remarks

Recognized shapes (checked in order):
1. raw value (not an object provider)
2. value provider: `{ useValue }`
3. factory providers: tuple | object | container | noDeps
4. class providers: tuple | object | container | noDeps

### Throws

Error with code ORK1099 when the provider shape is unknown (internal invariant)

### Example

```ts
const out = matchProvider(42, {
  raw: v => ({ useValue: v }),
  value: p => p,
  factoryTuple: p => p,
  factoryObject: p => p,
  factoryContainer: p => p,
  factoryNoDeps: p => p,
  classTuple: p => p,
  classObject: p => p,
  classContainer: p => p,
  classNoDeps: p => p,
})
```

---

## Function: register()

[**@orkestrel/core**](../index.md)

***

# Function: register()

Helper to construct a registration entry with typed inject preservation.
- Accepts tuple or object inject providers, or value/no-deps providers.
- options.dependencies: array or record of tokens; self-dependencies are ignored and duplicates are deduped.
- options.timeouts: per-node timeouts (number or per-phase object).

## Type Param

Token value type.

## Param

The component token.

## Param

Provider implementation (value/factory/class).

## Param

Optional dependencies and timeouts.

## Example

```ts
const entry = register(TOKEN, { useClass: Impl, inject: [DEP_A, DEP_B] }, { dependencies: [DEP_A, DEP_B] })
await app.start([entry])
```

## Call Signature

> **register**\<`T`, `A`\>(`token`, `provider`, `options?`): [`OrchestratorRegistration`](../interfaces/OrchestratorRegistration.md)\<`T`\>

Defined in: [orchestrator.ts:630](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L630)

### Type Parameters

#### T

`T`

#### A

`A` *extends* readonly `unknown`[]

### Parameters

#### token

[`Token`](../type-aliases/Token.md)\<`T`\>

#### provider

[`ClassProviderWithTuple`](../type-aliases/ClassProviderWithTuple.md)\<`T`, `A`\> | [`FactoryProviderWithTuple`](../type-aliases/FactoryProviderWithTuple.md)\<`T`, `A`\>

#### options?

[`RegisterOptions`](../interfaces/RegisterOptions.md)

### Returns

[`OrchestratorRegistration`](../interfaces/OrchestratorRegistration.md)\<`T`\>

## Call Signature

> **register**\<`T`, `O`\>(`token`, `provider`, `options?`): [`OrchestratorRegistration`](../interfaces/OrchestratorRegistration.md)\<`T`\>

Defined in: [orchestrator.ts:631](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L631)

### Type Parameters

#### T

`T`

#### O

`O` *extends* `Record`\<`string`, `unknown`\>

### Parameters

#### token

[`Token`](../type-aliases/Token.md)\<`T`\>

#### provider

[`ClassProviderWithObject`](../type-aliases/ClassProviderWithObject.md)\<`T`, `O`\> | [`FactoryProviderWithObject`](../type-aliases/FactoryProviderWithObject.md)\<`T`, `O`\>

#### options?

[`RegisterOptions`](../interfaces/RegisterOptions.md)

### Returns

[`OrchestratorRegistration`](../interfaces/OrchestratorRegistration.md)\<`T`\>

## Call Signature

> **register**\<`T`\>(`token`, `provider`, `options?`): [`OrchestratorRegistration`](../interfaces/OrchestratorRegistration.md)\<`T`\>

Defined in: [orchestrator.ts:632](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L632)

### Type Parameters

#### T

`T`

### Parameters

#### token

[`Token`](../type-aliases/Token.md)\<`T`\>

#### provider

[`Provider`](../type-aliases/Provider.md)\<`T`\>

#### options?

[`RegisterOptions`](../interfaces/RegisterOptions.md)

### Returns

[`OrchestratorRegistration`](../interfaces/OrchestratorRegistration.md)\<`T`\>

---

## Function: safeInvoke()

[**@orkestrel/core**](../index.md)

***

# Function: safeInvoke()

> **safeInvoke**\<`TArgs`\>(`fn`, ...`args`): `void`

Defined in: [helpers.ts:555](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L555)

Safely invoke an optional function with arguments, swallowing any errors.

## Type Parameters

### TArgs

`TArgs` *extends* `unknown`[]

Tuple type of function arguments

## Parameters

### fn

Optional function to invoke (no-op if undefined)

`undefined` | (...`args`) => `unknown`

### args

...`TArgs`

Arguments to pass to the function

## Returns

`void`

## Example

```ts
safeInvoke((x: number) => console.log(x), 1)
```

---

## Function: tokenDescription()

[**@orkestrel/core**](../index.md)

***

# Function: tokenDescription()

> **tokenDescription**(`token`): `string`

Defined in: [helpers.ts:575](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/helpers.ts#L575)

Helper to format token symbols consistently for logs and diagnostics.

## Parameters

### token

`symbol`

Symbol token to format

## Returns

`string`

The token's description or its string representation

## Example

```ts
tokenDescription(Symbol('UserService')) // 'UserService'
```

---

## Orkestrel Core

**@orkestrel/core**

***

# Orkestrel Core

Minimal, strongly-typed adapter/port toolkit for TypeScript. Compose capabilities with tokens, wire implementations via a tiny DI container, and drive lifecycles deterministically with an orchestrator.

- Package: `@orkestrel/core`
- TypeScript-first, ESM-only
- Works in Node and the browser (Node 18+)

## Install
```sh
npm install @orkestrel/core
```

## Documentation
- Overview: docs/guide/overview.md
- Start: docs/guide/start.md
- Concepts: docs/guide/concepts.md
- Core: docs/guide/core.md
- Examples: docs/guide/examples.md
- Tips: docs/guide/tips.md
- Tests: docs/guide/tests.md
- Contribute: docs/guide/contribute.md
- FAQ: docs/guide/faq.md
- API: docs/api/index.md
- LLM: docs/llms.txt
- LLM Full: docs/llms-full.txt

Notes
- Providers are synchronous (no async factories or Promise values). Do async work in Lifecycle hooks.
- Deterministic start/stop/destroy order with timeouts and rollback on failures.

## Scripts
```sh
npm run check   # typecheck
npm run test    # unit tests
npm run docs    # generate API docs into docs/api
npm run build   # build ESM + types into dist
```

Links
- Issues: https://github.com/orkestrel/core/issues

Orkestrel Core - Minimal, strongly-typed adapter/port toolkit for TypeScript.

This package provides a lightweight dependency injection container, lifecycle management,
and orchestration primitives for building composable applications with ports and adapters.

## Classes

- [Adapter](classes/Adapter.md)
- [Container](classes/Container.md)
- [DiagnosticAdapter](classes/DiagnosticAdapter.md)
- [EmitterAdapter](classes/EmitterAdapter.md)
- [EventAdapter](classes/EventAdapter.md)
- [LayerAdapter](classes/LayerAdapter.md)
- [Lifecycle](classes/Lifecycle.md)
- [LoggerAdapter](classes/LoggerAdapter.md)
- [NoopLogger](classes/NoopLogger.md)
- [Orchestrator](classes/Orchestrator.md)
- [QueueAdapter](classes/QueueAdapter.md)
- [RegistryAdapter](classes/RegistryAdapter.md)

## Interfaces

- [ContainerOptions](interfaces/ContainerOptions.md)
- [DiagnosticAdapterOptions](interfaces/DiagnosticAdapterOptions.md)
- [DiagnosticErrorContext](interfaces/DiagnosticErrorContext.md)
- [DiagnosticMessage](interfaces/DiagnosticMessage.md)
- [DiagnosticPort](interfaces/DiagnosticPort.md)
- [EmitterAdapterOptions](interfaces/EmitterAdapterOptions.md)
- [EmitterPort](interfaces/EmitterPort.md)
- [EventAdapterOptions](interfaces/EventAdapterOptions.md)
- [EventPort](interfaces/EventPort.md)
- [LayerAdapterOptions](interfaces/LayerAdapterOptions.md)
- [LayerNode](interfaces/LayerNode.md)
- [LayerPort](interfaces/LayerPort.md)
- [LifecycleErrorDetail](interfaces/LifecycleErrorDetail.md)
- [LifecycleOptions](interfaces/LifecycleOptions.md)
- [LoggerPort](interfaces/LoggerPort.md)
- [NodeEntry](interfaces/NodeEntry.md)
- [OrchestratorOptions](interfaces/OrchestratorOptions.md)
- [OrchestratorRegistration](interfaces/OrchestratorRegistration.md)
- [QueueAdapterOptions](interfaces/QueueAdapterOptions.md)
- [QueuePort](interfaces/QueuePort.md)
- [QueueRunOptions](interfaces/QueueRunOptions.md)
- [RegisterOptions](interfaces/RegisterOptions.md)
- [Registration](interfaces/Registration.md)
- [RegistryAdapterOptions](interfaces/RegistryAdapterOptions.md)
- [RegistryPort](interfaces/RegistryPort.md)
- [ResolvedProvider](interfaces/ResolvedProvider.md)
- [ValueProvider](interfaces/ValueProvider.md)

## Type Aliases

- [AggregateLifecycleError](type-aliases/AggregateLifecycleError.md)
- [ClassProvider](type-aliases/ClassProvider.md)
- [ClassProviderNoDeps](type-aliases/ClassProviderNoDeps.md)
- [ClassProviderWithContainer](type-aliases/ClassProviderWithContainer.md)
- [ClassProviderWithObject](type-aliases/ClassProviderWithObject.md)
- [ClassProviderWithTuple](type-aliases/ClassProviderWithTuple.md)
- [ContainerGetter](type-aliases/ContainerGetter.md)
- [CtorNoDeps](type-aliases/CtorNoDeps.md)
- [CtorWithContainer](type-aliases/CtorWithContainer.md)
- [DestroyJobResult](type-aliases/DestroyJobResult.md)
- [DiagnosticScope](type-aliases/DiagnosticScope.md)
- [EmitterListener](type-aliases/EmitterListener.md)
- [EventHandler](type-aliases/EventHandler.md)
- [EventMap](type-aliases/EventMap.md)
- [FactoryProvider](type-aliases/FactoryProvider.md)
- [FactoryProviderNoDeps](type-aliases/FactoryProviderNoDeps.md)
- [FactoryProviderWithContainer](type-aliases/FactoryProviderWithContainer.md)
- [FactoryProviderWithObject](type-aliases/FactoryProviderWithObject.md)
- [FactoryProviderWithTuple](type-aliases/FactoryProviderWithTuple.md)
- [FromSchema](type-aliases/FromSchema.md)
- [Guard](type-aliases/Guard.md)
- [InjectObject](type-aliases/InjectObject.md)
- [InjectTuple](type-aliases/InjectTuple.md)
- [LifecycleContext](type-aliases/LifecycleContext.md)
- [LifecycleEventMap](type-aliases/LifecycleEventMap.md)
- [LifecycleHook](type-aliases/LifecycleHook.md)
- [LifecyclePhase](type-aliases/LifecyclePhase.md)
- [LifecycleState](type-aliases/LifecycleState.md)
- [LogLevel](type-aliases/LogLevel.md)
- [MessageMapEntry](type-aliases/MessageMapEntry.md)
- [OptionalResolvedMap](type-aliases/OptionalResolvedMap.md)
- [OrchestratorGetter](type-aliases/OrchestratorGetter.md)
- [OrchestratorStartResult](type-aliases/OrchestratorStartResult.md)
- [Outcome](type-aliases/Outcome.md)
- [PhaseResult](type-aliases/PhaseResult.md)
- [PhaseResultErr](type-aliases/PhaseResultErr.md)
- [PhaseResultOk](type-aliases/PhaseResultOk.md)
- [PhaseTimeouts](type-aliases/PhaseTimeouts.md)
- [PrimitiveTag](type-aliases/PrimitiveTag.md)
- [Provider](type-aliases/Provider.md)
- [ProviderMatchHandlers](type-aliases/ProviderMatchHandlers.md)
- [ProviderMatchReturnHandlers](type-aliases/ProviderMatchReturnHandlers.md)
- [ResolvedMap](type-aliases/ResolvedMap.md)
- [ResolveRule](type-aliases/ResolveRule.md)
- [SchemaSpec](type-aliases/SchemaSpec.md)
- [Task](type-aliases/Task.md)
- [Token](type-aliases/Token.md)
- [TokenRecord](type-aliases/TokenRecord.md)
- [TokensOf](type-aliases/TokensOf.md)

## Variables

- [container](variables/container.md)
- [CONTAINER\_MESSAGES](variables/CONTAINER_MESSAGES.md)
- [HELP](variables/HELP.md)
- [INTERNAL\_MESSAGES](variables/INTERNAL_MESSAGES.md)
- [LIFECYCLE\_MESSAGES](variables/LIFECYCLE_MESSAGES.md)
- [orchestrator](variables/orchestrator.md)
- [ORCHESTRATOR\_MESSAGES](variables/ORCHESTRATOR_MESSAGES.md)
- [PORTS\_MESSAGES](variables/PORTS_MESSAGES.md)
- [QUEUE\_MESSAGES](variables/QUEUE_MESSAGES.md)
- [REGISTRY\_MESSAGES](variables/REGISTRY_MESSAGES.md)

## Functions

- [arrayOf](functions/arrayOf.md)
- [createPortToken](functions/createPortToken.md)
- [createPortTokens](functions/createPortTokens.md)
- [createToken](functions/createToken.md)
- [createTokens](functions/createTokens.md)
- [extendPorts](functions/extendPorts.md)
- [getTag](functions/getTag.md)
- [hasOwn](functions/hasOwn.md)
- [hasSchema](functions/hasSchema.md)
- [isAggregateLifecycleError](functions/isAggregateLifecycleError.md)
- [isAsyncFunction](functions/isAsyncFunction.md)
- [isBoolean](functions/isBoolean.md)
- [isClassProvider](functions/isClassProvider.md)
- [isClassProviderNoDeps](functions/isClassProviderNoDeps.md)
- [isClassProviderWithContainer](functions/isClassProviderWithContainer.md)
- [isClassProviderWithObject](functions/isClassProviderWithObject.md)
- [isClassProviderWithTuple](functions/isClassProviderWithTuple.md)
- [isFactoryProvider](functions/isFactoryProvider.md)
- [isFactoryProviderNoDeps](functions/isFactoryProviderNoDeps.md)
- [isFactoryProviderWithContainer](functions/isFactoryProviderWithContainer.md)
- [isFactoryProviderWithObject](functions/isFactoryProviderWithObject.md)
- [isFactoryProviderWithTuple](functions/isFactoryProviderWithTuple.md)
- [isFiniteNumber](functions/isFiniteNumber.md)
- [isLifecycleErrorDetail](functions/isLifecycleErrorDetail.md)
- [isObject](functions/isObject.md)
- [isPromiseLike](functions/isPromiseLike.md)
- [isProviderObject](functions/isProviderObject.md)
- [isRawProviderValue](functions/isRawProviderValue.md)
- [isString](functions/isString.md)
- [isToken](functions/isToken.md)
- [isTokenArray](functions/isTokenArray.md)
- [isTokenRecord](functions/isTokenRecord.md)
- [isValueProvider](functions/isValueProvider.md)
- [isZeroArg](functions/isZeroArg.md)
- [literalOf](functions/literalOf.md)
- [matchProvider](functions/matchProvider.md)
- [register](functions/register.md)
- [safeInvoke](functions/safeInvoke.md)
- [tokenDescription](functions/tokenDescription.md)

---

## Interface: ContainerOptions

[**@orkestrel/core**](../index.md)

***

# Interface: ContainerOptions

Defined in: [types.ts:248](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L248)

## Properties

### diagnostic?

> `readonly` `optional` **diagnostic**: [`DiagnosticPort`](DiagnosticPort.md)

Defined in: [types.ts:248](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L248)

***

### logger?

> `readonly` `optional` **logger**: [`LoggerPort`](LoggerPort.md)

Defined in: [types.ts:248](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L248)

***

### parent?

> `readonly` `optional` **parent**: [`Container`](../classes/Container.md)

Defined in: [types.ts:248](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L248)

---

## Interface: DiagnosticAdapterOptions

[**@orkestrel/core**](../index.md)

***

# Interface: DiagnosticAdapterOptions

Defined in: [types.ts:154](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L154)

## Properties

### logger?

> `readonly` `optional` **logger**: [`LoggerPort`](LoggerPort.md)

Defined in: [types.ts:154](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L154)

***

### messages?

> `readonly` `optional` **messages**: readonly [`DiagnosticMessage`](DiagnosticMessage.md)[]

Defined in: [types.ts:154](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L154)

---

## Interface: DiagnosticErrorContext

[**@orkestrel/core**](../index.md)

***

# Interface: DiagnosticErrorContext

Defined in: [types.ts:129](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L129)

## Properties

### code?

> `readonly` `optional` **code**: `string`

Defined in: [types.ts:131](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L131)

***

### details?

> `readonly` `optional` **details**: readonly [`LifecycleErrorDetail`](LifecycleErrorDetail.md)[]

Defined in: [types.ts:138](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L138)

***

### durationMs?

> `readonly` `optional` **durationMs**: `number`

Defined in: [types.ts:136](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L136)

***

### extra?

> `readonly` `optional` **extra**: `Record`\<`string`, `unknown`\>

Defined in: [types.ts:137](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L137)

***

### hook?

> `readonly` `optional` **hook**: [`LifecycleHook`](../type-aliases/LifecycleHook.md)

Defined in: [types.ts:134](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L134)

***

### phase?

> `readonly` `optional` **phase**: [`LifecyclePhase`](../type-aliases/LifecyclePhase.md)

Defined in: [types.ts:133](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L133)

***

### scope?

> `readonly` `optional` **scope**: [`DiagnosticScope`](../type-aliases/DiagnosticScope.md)

Defined in: [types.ts:130](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L130)

***

### timedOut?

> `readonly` `optional` **timedOut**: `boolean`

Defined in: [types.ts:135](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L135)

***

### token?

> `readonly` `optional` **token**: `string`

Defined in: [types.ts:132](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L132)

---

## Interface: DiagnosticMessage

[**@orkestrel/core**](../index.md)

***

# Interface: DiagnosticMessage

Defined in: [types.ts:153](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L153)

## Extends

- [`MessageMapEntry`](../type-aliases/MessageMapEntry.md)

## Properties

### key

> `readonly` **key**: `string`

Defined in: [types.ts:153](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L153)

***

### level?

> `readonly` `optional` **level**: [`LogLevel`](../type-aliases/LogLevel.md)

Defined in: [types.ts:152](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L152)

#### Inherited from

`MessageMapEntry.level`

***

### message?

> `readonly` `optional` **message**: `string`

Defined in: [types.ts:152](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L152)

#### Inherited from

`MessageMapEntry.message`

---

## Interface: DiagnosticPort

[**@orkestrel/core**](../index.md)

***

# Interface: DiagnosticPort

Defined in: [types.ts:141](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L141)

## Methods

### aggregate()

> **aggregate**(`key`, `details`, `context?`): `never`

Defined in: [types.ts:145](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L145)

#### Parameters

##### key

`string`

##### details

readonly (`Error` \| [`LifecycleErrorDetail`](LifecycleErrorDetail.md))[]

##### context?

[`DiagnosticErrorContext`](DiagnosticErrorContext.md) & `object`

#### Returns

`never`

***

### error()

> **error**(`err`, `context?`): `void`

Defined in: [types.ts:143](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L143)

#### Parameters

##### err

`unknown`

##### context?

[`DiagnosticErrorContext`](DiagnosticErrorContext.md)

#### Returns

`void`

***

### event()

> **event**(`name`, `payload?`): `void`

Defined in: [types.ts:149](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L149)

#### Parameters

##### name

`string`

##### payload?

`Record`\<`string`, `unknown`\>

#### Returns

`void`

***

### fail()

> **fail**(`key`, `context?`): `never`

Defined in: [types.ts:144](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L144)

#### Parameters

##### key

`string`

##### context?

[`DiagnosticErrorContext`](DiagnosticErrorContext.md) & `object`

#### Returns

`never`

***

### help()

> **help**(`key`, `context?`): `Error`

Defined in: [types.ts:146](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L146)

#### Parameters

##### key

`string`

##### context?

[`DiagnosticErrorContext`](DiagnosticErrorContext.md) & `object`

#### Returns

`Error`

***

### log()

> **log**(`level`, `message`, `fields?`): `void`

Defined in: [types.ts:142](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L142)

#### Parameters

##### level

[`LogLevel`](../type-aliases/LogLevel.md)

##### message

`string`

##### fields?

`Record`\<`string`, `unknown`\>

#### Returns

`void`

***

### metric()

> **metric**(`name`, `value`, `tags?`): `void`

Defined in: [types.ts:147](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L147)

#### Parameters

##### name

`string`

##### value

`number`

##### tags?

`Record`\<`string`, `string` \| `number` \| `boolean`\>

#### Returns

`void`

***

### trace()

> **trace**(`name`, `payload?`): `void`

Defined in: [types.ts:148](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L148)

#### Parameters

##### name

`string`

##### payload?

`Record`\<`string`, `unknown`\>

#### Returns

`void`

---

## Interface: EmitterAdapterOptions

[**@orkestrel/core**](../index.md)

***

# Interface: EmitterAdapterOptions

Defined in: [types.ts:171](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L171)

## Properties

### diagnostic?

> `readonly` `optional` **diagnostic**: [`DiagnosticPort`](DiagnosticPort.md)

Defined in: [types.ts:171](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L171)

***

### logger?

> `readonly` `optional` **logger**: [`LoggerPort`](LoggerPort.md)

Defined in: [types.ts:171](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L171)

---

## Interface: EmitterPort\<EMap\>

[**@orkestrel/core**](../index.md)

***

# Interface: EmitterPort\<EMap\>

Defined in: [types.ts:164](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L164)

## Type Parameters

### EMap

`EMap` *extends* [`EventMap`](../type-aliases/EventMap.md) = [`EventMap`](../type-aliases/EventMap.md)

## Methods

### emit()

> **emit**\<`E`\>(`event`, ...`args`): `void`

Defined in: [types.ts:167](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L167)

#### Type Parameters

##### E

`E` *extends* `string`

#### Parameters

##### event

`E`

##### args

...`EMap`\[`E`\]

#### Returns

`void`

***

### off()

> **off**\<`E`\>(`event`, `fn`): `this`

Defined in: [types.ts:166](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L166)

#### Type Parameters

##### E

`E` *extends* `string`

#### Parameters

##### event

`E`

##### fn

[`EmitterListener`](../type-aliases/EmitterListener.md)\<`EMap`, `E`\>

#### Returns

`this`

***

### on()

> **on**\<`E`\>(`event`, `fn`): `this`

Defined in: [types.ts:165](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L165)

#### Type Parameters

##### E

`E` *extends* `string`

#### Parameters

##### event

`E`

##### fn

[`EmitterListener`](../type-aliases/EmitterListener.md)\<`EMap`, `E`\>

#### Returns

`this`

***

### removeAllListeners()

> **removeAllListeners**(): `void`

Defined in: [types.ts:168](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L168)

#### Returns

`void`

---

## Interface: EventAdapterOptions

[**@orkestrel/core**](../index.md)

***

# Interface: EventAdapterOptions

Defined in: [types.ts:181](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L181)

## Properties

### diagnostic?

> `readonly` `optional` **diagnostic**: [`DiagnosticPort`](DiagnosticPort.md)

Defined in: [types.ts:185](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L185)

***

### logger?

> `readonly` `optional` **logger**: [`LoggerPort`](LoggerPort.md)

Defined in: [types.ts:184](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L184)

***

### onError()?

> `readonly` `optional` **onError**: (`err`, `topic`) => `void`

Defined in: [types.ts:182](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L182)

#### Parameters

##### err

`unknown`

##### topic

`string`

#### Returns

`void`

***

### sequential?

> `readonly` `optional` **sequential**: `boolean`

Defined in: [types.ts:183](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L183)

---

## Interface: EventPort\<EMap\>

[**@orkestrel/core**](../index.md)

***

# Interface: EventPort\<EMap\>

Defined in: [types.ts:175](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L175)

## Type Parameters

### EMap

`EMap` *extends* `Record`\<`string`, `unknown`\> = `Record`\<`string`, `unknown`\>

## Methods

### publish()

> **publish**\<`E`\>(`topic`, `payload`): `Promise`\<`void`\>

Defined in: [types.ts:176](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L176)

#### Type Parameters

##### E

`E` *extends* `string`

#### Parameters

##### topic

`E`

##### payload

`EMap`\[`E`\]

#### Returns

`Promise`\<`void`\>

***

### subscribe()

> **subscribe**\<`E`\>(`topic`, `handler`): `Promise`\<() => `void` \| `Promise`\<`void`\>\>

Defined in: [types.ts:177](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L177)

#### Type Parameters

##### E

`E` *extends* `string`

#### Parameters

##### topic

`E`

##### handler

[`EventHandler`](../type-aliases/EventHandler.md)\<`EMap`\[`E`\]\>

#### Returns

`Promise`\<() => `void` \| `Promise`\<`void`\>\>

***

### topics()

> **topics**(): readonly `string`[]

Defined in: [types.ts:178](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L178)

#### Returns

readonly `string`[]

---

## Interface: LayerAdapterOptions

[**@orkestrel/core**](../index.md)

***

# Interface: LayerAdapterOptions

Defined in: [types.ts:220](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L220)

## Properties

### diagnostic?

> `readonly` `optional` **diagnostic**: [`DiagnosticPort`](DiagnosticPort.md)

Defined in: [types.ts:220](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L220)

***

### logger?

> `readonly` `optional` **logger**: [`LoggerPort`](LoggerPort.md)

Defined in: [types.ts:220](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L220)

---

## Interface: LayerNode\<T\>

[**@orkestrel/core**](../index.md)

***

# Interface: LayerNode\<T\>

Defined in: [types.ts:210](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L210)

## Type Parameters

### T

`T` = `unknown`

## Properties

### dependencies

> `readonly` **dependencies**: readonly [`Token`](../type-aliases/Token.md)\<`unknown`\>[]

Defined in: [types.ts:212](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L212)

***

### token

> `readonly` **token**: [`Token`](../type-aliases/Token.md)\<`T`\>

Defined in: [types.ts:211](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L211)

---

## Interface: LayerPort

[**@orkestrel/core**](../index.md)

***

# Interface: LayerPort

Defined in: [types.ts:215](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L215)

## Methods

### compute()

> **compute**\<`T`\>(`nodes`): [`Token`](../type-aliases/Token.md)\<`T`\>[][]

Defined in: [types.ts:216](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L216)

#### Type Parameters

##### T

`T`

#### Parameters

##### nodes

readonly [`LayerNode`](LayerNode.md)\<`T`\>[]

#### Returns

[`Token`](../type-aliases/Token.md)\<`T`\>[][]

***

### group()

> **group**\<`T`\>(`tokens`, `layers`): [`Token`](../type-aliases/Token.md)\<`T`\>[][]

Defined in: [types.ts:217](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L217)

#### Type Parameters

##### T

`T`

#### Parameters

##### tokens

readonly [`Token`](../type-aliases/Token.md)\<`T`\>[]

##### layers

readonly readonly [`Token`](../type-aliases/Token.md)\<`T`\>[][]

#### Returns

[`Token`](../type-aliases/Token.md)\<`T`\>[][]

---

## Interface: LifecycleErrorDetail

[**@orkestrel/core**](../index.md)

***

# Interface: LifecycleErrorDetail

Defined in: [types.ts:120](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L120)

## Properties

### context

> **context**: [`LifecycleContext`](../type-aliases/LifecycleContext.md)

Defined in: [types.ts:123](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L123)

***

### durationMs

> **durationMs**: `number`

Defined in: [types.ts:125](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L125)

***

### error

> **error**: `Error`

Defined in: [types.ts:126](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L126)

***

### phase

> **phase**: [`LifecyclePhase`](../type-aliases/LifecyclePhase.md)

Defined in: [types.ts:122](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L122)

***

### timedOut

> **timedOut**: `boolean`

Defined in: [types.ts:124](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L124)

***

### tokenDescription

> **tokenDescription**: `string`

Defined in: [types.ts:121](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L121)

---

## Interface: LifecycleOptions

[**@orkestrel/core**](../index.md)

***

# Interface: LifecycleOptions

Defined in: [types.ts:236](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L236)

## Properties

### diagnostic?

> `readonly` `optional` **diagnostic**: [`DiagnosticPort`](DiagnosticPort.md)

Defined in: [types.ts:242](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L242)

***

### emitInitial?

> `readonly` `optional` **emitInitial**: `boolean`

Defined in: [types.ts:238](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L238)

***

### emitter?

> `readonly` `optional` **emitter**: [`EmitterPort`](EmitterPort.md)\<[`LifecycleEventMap`](../type-aliases/LifecycleEventMap.md)\>

Defined in: [types.ts:239](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L239)

***

### logger?

> `readonly` `optional` **logger**: [`LoggerPort`](LoggerPort.md)

Defined in: [types.ts:241](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L241)

***

### queue?

> `readonly` `optional` **queue**: [`QueuePort`](QueuePort.md)\<`unknown`\>

Defined in: [types.ts:240](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L240)

***

### timeouts?

> `readonly` `optional` **timeouts**: `number`

Defined in: [types.ts:237](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L237)

---

## Interface: LoggerPort

[**@orkestrel/core**](../index.md)

***

# Interface: LoggerPort

Defined in: [types.ts:110](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L110)

## Methods

### log()

> **log**(`level`, `message`, `fields?`): `void`

Defined in: [types.ts:111](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L111)

#### Parameters

##### level

[`LogLevel`](../type-aliases/LogLevel.md)

##### message

`string`

##### fields?

`Record`\<`string`, `unknown`\>

#### Returns

`void`

---

## Interface: NodeEntry

[**@orkestrel/core**](../index.md)

***

# Interface: NodeEntry

Defined in: [types.ts:325](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L325)

## Properties

### dependencies

> `readonly` **dependencies**: readonly [`Token`](../type-aliases/Token.md)\<`unknown`\>[]

Defined in: [types.ts:325](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L325)

***

### timeouts?

> `readonly` `optional` **timeouts**: `number` \| `Readonly`\<\{ `onDestroy?`: `number`; `onStart?`: `number`; `onStop?`: `number`; \}\>

Defined in: [types.ts:325](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L325)

***

### token

> `readonly` **token**: [`Token`](../type-aliases/Token.md)\<`unknown`\>

Defined in: [types.ts:325](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L325)

---

## Interface: OrchestratorOptions

[**@orkestrel/core**](../index.md)

***

# Interface: OrchestratorOptions

Defined in: [types.ts:295](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L295)

## Properties

### diagnostic?

> `readonly` `optional` **diagnostic**: [`DiagnosticPort`](DiagnosticPort.md)

Defined in: [types.ts:310](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L310)

***

### events?

> `readonly` `optional` **events**: `object`

Defined in: [types.ts:297](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L297)

#### onComponentDestroy()?

> `optional` **onComponentDestroy**: (`info`) => `void`

##### Parameters

###### info

###### durationMs

`number`

###### token

[`Token`](../type-aliases/Token.md)\<`unknown`\>

##### Returns

`void`

#### onComponentError()?

> `optional` **onComponentError**: (`detail`) => `void`

##### Parameters

###### detail

[`LifecycleErrorDetail`](LifecycleErrorDetail.md)

##### Returns

`void`

#### onComponentStart()?

> `optional` **onComponentStart**: (`info`) => `void`

##### Parameters

###### info

###### durationMs

`number`

###### token

[`Token`](../type-aliases/Token.md)\<`unknown`\>

##### Returns

`void`

#### onComponentStop()?

> `optional` **onComponentStop**: (`info`) => `void`

##### Parameters

###### info

###### durationMs

`number`

###### token

[`Token`](../type-aliases/Token.md)\<`unknown`\>

##### Returns

`void`

***

### layer?

> `readonly` `optional` **layer**: [`LayerPort`](LayerPort.md)

Defined in: [types.ts:307](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L307)

***

### logger?

> `readonly` `optional` **logger**: [`LoggerPort`](LoggerPort.md)

Defined in: [types.ts:309](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L309)

***

### queue?

> `readonly` `optional` **queue**: [`QueuePort`](QueuePort.md)\<`unknown`\>

Defined in: [types.ts:308](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L308)

***

### timeouts?

> `readonly` `optional` **timeouts**: `number` \| `Readonly`\<\{ `onDestroy?`: `number`; `onStart?`: `number`; `onStop?`: `number`; \}\>

Defined in: [types.ts:296](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L296)

***

### tracer?

> `readonly` `optional` **tracer**: `object`

Defined in: [types.ts:303](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L303)

#### onLayers()?

> `optional` **onLayers**: (`payload`) => `void`

##### Parameters

###### payload

###### layers

`string`[][]

##### Returns

`void`

#### onPhase()?

> `optional` **onPhase**: (`payload`) => `void`

##### Parameters

###### payload

###### layer

`number`

###### outcomes

`Readonly`\<\{ `durationMs`: `number`; `ok`: `boolean`; `timedOut?`: `boolean`; `token`: `string`; \}\>[]

###### phase

[`LifecyclePhase`](../type-aliases/LifecyclePhase.md)

##### Returns

`void`

---

## Interface: OrchestratorRegistration\<T\>

[**@orkestrel/core**](../index.md)

***

# Interface: OrchestratorRegistration\<T\>

Defined in: [types.ts:288](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L288)

## Type Parameters

### T

`T`

## Properties

### dependencies?

> `readonly` `optional` **dependencies**: readonly [`Token`](../type-aliases/Token.md)\<`unknown`\>[]

Defined in: [types.ts:291](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L291)

***

### provider

> `readonly` **provider**: [`Provider`](../type-aliases/Provider.md)\<`T`\>

Defined in: [types.ts:290](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L290)

***

### timeouts?

> `readonly` `optional` **timeouts**: `number` \| `Readonly`\<\{ `onDestroy?`: `number`; `onStart?`: `number`; `onStop?`: `number`; \}\>

Defined in: [types.ts:292](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L292)

***

### token

> `readonly` **token**: [`Token`](../type-aliases/Token.md)\<`T`\>

Defined in: [types.ts:289](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L289)

---

## Interface: QueueAdapterOptions

[**@orkestrel/core**](../index.md)

***

# Interface: QueueAdapterOptions

Defined in: [types.ts:205](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L205)

## Extends

- [`QueueRunOptions`](QueueRunOptions.md)

## Properties

### capacity?

> `readonly` `optional` **capacity**: `number`

Defined in: [types.ts:205](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L205)

***

### concurrency?

> `readonly` `optional` **concurrency**: `number`

Defined in: [types.ts:192](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L192)

#### Inherited from

[`QueueRunOptions`](QueueRunOptions.md).[`concurrency`](QueueRunOptions.md#concurrency)

***

### deadline?

> `readonly` `optional` **deadline**: `number`

Defined in: [types.ts:194](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L194)

#### Inherited from

[`QueueRunOptions`](QueueRunOptions.md).[`deadline`](QueueRunOptions.md#deadline)

***

### diagnostic?

> `readonly` `optional` **diagnostic**: [`DiagnosticPort`](DiagnosticPort.md)

Defined in: [types.ts:205](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L205)

***

### logger?

> `readonly` `optional` **logger**: [`LoggerPort`](LoggerPort.md)

Defined in: [types.ts:205](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L205)

***

### signal?

> `readonly` `optional` **signal**: `AbortSignal`

Defined in: [types.ts:195](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L195)

#### Inherited from

[`QueueRunOptions`](QueueRunOptions.md).[`signal`](QueueRunOptions.md#signal)

***

### timeout?

> `readonly` `optional` **timeout**: `number`

Defined in: [types.ts:193](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L193)

#### Inherited from

[`QueueRunOptions`](QueueRunOptions.md).[`timeout`](QueueRunOptions.md#timeout)

---

## Interface: QueuePort\<T\>

[**@orkestrel/core**](../index.md)

***

# Interface: QueuePort\<T\>

Defined in: [types.ts:198](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L198)

## Type Parameters

### T

`T` = `unknown`

## Methods

### dequeue()

> **dequeue**(): `Promise`\<`undefined` \| `T`\>

Defined in: [types.ts:200](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L200)

#### Returns

`Promise`\<`undefined` \| `T`\>

***

### enqueue()

> **enqueue**(`item`): `Promise`\<`void`\>

Defined in: [types.ts:199](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L199)

#### Parameters

##### item

`T`

#### Returns

`Promise`\<`void`\>

***

### run()

> **run**\<`R`\>(`tasks`, `options?`): `Promise`\<readonly `R`[]\>

Defined in: [types.ts:202](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L202)

#### Type Parameters

##### R

`R`

#### Parameters

##### tasks

readonly () => `R` \| `Promise`\<`R`\>[]

##### options?

[`QueueRunOptions`](QueueRunOptions.md)

#### Returns

`Promise`\<readonly `R`[]\>

***

### size()

> **size**(): `Promise`\<`number`\>

Defined in: [types.ts:201](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L201)

#### Returns

`Promise`\<`number`\>

---

## Interface: QueueRunOptions

[**@orkestrel/core**](../index.md)

***

# Interface: QueueRunOptions

Defined in: [types.ts:191](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L191)

## Extended by

- [`QueueAdapterOptions`](QueueAdapterOptions.md)

## Properties

### concurrency?

> `readonly` `optional` **concurrency**: `number`

Defined in: [types.ts:192](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L192)

***

### deadline?

> `readonly` `optional` **deadline**: `number`

Defined in: [types.ts:194](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L194)

***

### signal?

> `readonly` `optional` **signal**: `AbortSignal`

Defined in: [types.ts:195](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L195)

***

### timeout?

> `readonly` `optional` **timeout**: `number`

Defined in: [types.ts:193](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L193)

---

## Interface: RegisterOptions

[**@orkestrel/core**](../index.md)

***

# Interface: RegisterOptions

Defined in: [types.ts:320](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L320)

## Properties

### dependencies?

> `optional` **dependencies**: `Record`\<`string`, [`Token`](../type-aliases/Token.md)\<`unknown`\>\> \| [`Token`](../type-aliases/Token.md)\<`unknown`\>[]

Defined in: [types.ts:321](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L321)

***

### timeouts?

> `optional` **timeouts**: `number` \| `Readonly`\<\{ `onDestroy?`: `number`; `onStart?`: `number`; `onStop?`: `number`; \}\>

Defined in: [types.ts:322](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L322)

---

## Interface: Registration\<T\>

[**@orkestrel/core**](../index.md)

***

# Interface: Registration\<T\>

Defined in: [types.ts:251](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L251)

## Type Parameters

### T

`T`

## Properties

### provider

> **provider**: [`Provider`](../type-aliases/Provider.md)\<`T`\>

Defined in: [types.ts:251](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L251)

***

### resolved?

> `optional` **resolved**: [`ResolvedProvider`](ResolvedProvider.md)\<`T`\>

Defined in: [types.ts:251](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L251)

***

### token

> **token**: [`Token`](../type-aliases/Token.md)\<`T`\>

Defined in: [types.ts:251](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L251)

---

## Interface: RegistryAdapterOptions\<T\>

[**@orkestrel/core**](../index.md)

***

# Interface: RegistryAdapterOptions\<T\>

Defined in: [types.ts:338](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L338)

## Type Parameters

### T

`T`

## Properties

### default?

> `readonly` `optional` **default**: `object`

Defined in: [types.ts:340](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L340)

#### key?

> `readonly` `optional` **key**: `symbol`

#### value

> `readonly` **value**: `T`

***

### diagnostic?

> `readonly` `optional` **diagnostic**: [`DiagnosticPort`](DiagnosticPort.md)

Defined in: [types.ts:342](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L342)

***

### label?

> `readonly` `optional` **label**: `string`

Defined in: [types.ts:339](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L339)

***

### logger?

> `readonly` `optional` **logger**: [`LoggerPort`](LoggerPort.md)

Defined in: [types.ts:341](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L341)

---

## Interface: RegistryPort\<T\>

[**@orkestrel/core**](../index.md)

***

# Interface: RegistryPort\<T\>

Defined in: [types.ts:330](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L330)

## Type Parameters

### T

`T`

## Methods

### clear()

> **clear**(`name?`, `force?`): `boolean`

Defined in: [types.ts:334](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L334)

#### Parameters

##### name?

`string` | `symbol`

##### force?

`boolean`

#### Returns

`boolean`

***

### get()

> **get**(`name?`): `undefined` \| `T`

Defined in: [types.ts:331](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L331)

#### Parameters

##### name?

`string` | `symbol`

#### Returns

`undefined` \| `T`

***

### list()

> **list**(): readonly (`string` \| `symbol`)[]

Defined in: [types.ts:335](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L335)

#### Returns

readonly (`string` \| `symbol`)[]

***

### resolve()

> **resolve**(`name?`): `T`

Defined in: [types.ts:332](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L332)

#### Parameters

##### name?

`string` | `symbol`

#### Returns

`T`

***

### set()

> **set**(`name`, `value`, `lock?`): `void`

Defined in: [types.ts:333](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L333)

#### Parameters

##### name

`string` | `symbol`

##### value

`T`

##### lock?

`boolean`

#### Returns

`void`

---

## Interface: ResolvedProvider\<T\>

[**@orkestrel/core**](../index.md)

***

# Interface: ResolvedProvider\<T\>

Defined in: [types.ts:250](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L250)

## Type Parameters

### T

`T`

## Properties

### disposable

> **disposable**: `boolean`

Defined in: [types.ts:250](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L250)

***

### lifecycle?

> `optional` **lifecycle**: [`Lifecycle`](../classes/Lifecycle.md)

Defined in: [types.ts:250](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L250)

***

### value

> **value**: `T`

Defined in: [types.ts:250](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L250)

---

## Interface: ValueProvider\<T\>

[**@orkestrel/core**](../index.md)

***

# Interface: ValueProvider\<T\>

Defined in: [types.ts:14](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L14)

## Type Parameters

### T

`T`

## Properties

### useValue

> `readonly` **useValue**: `T`

Defined in: [types.ts:14](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L14)

---

## Type Alias: AggregateLifecycleError

[**@orkestrel/core**](../index.md)

***

# Type Alias: AggregateLifecycleError

> **AggregateLifecycleError** = `Error` & `Readonly`\<\{ `code?`: `string`; `details`: `ReadonlyArray`\<[`LifecycleErrorDetail`](../interfaces/LifecycleErrorDetail.md)\>; `errors`: `ReadonlyArray`\<`Error`\>; `helpUrl?`: `string`; \}\>

Defined in: [types.ts:156](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L156)

---

## Type Alias: ClassProvider\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: ClassProvider\<T\>

> **ClassProvider**\<`T`\> = [`ClassProviderNoDeps`](ClassProviderNoDeps.md)\<`T`\> \| [`ClassProviderWithContainer`](ClassProviderWithContainer.md)\<`T`\> \| [`ClassProviderWithTuple`](ClassProviderWithTuple.md)\<`T`, readonly `unknown`[]\> \| [`ClassProviderWithObject`](ClassProviderWithObject.md)\<`T`, `Record`\<`string`, `unknown`\>\>

Defined in: [types.ts:53](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L53)

## Type Parameters

### T

`T`

---

## Type Alias: ClassProviderNoDeps\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: ClassProviderNoDeps\<T\>

> **ClassProviderNoDeps**\<`T`\> = `object`

Defined in: [types.ts:42](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L42)

## Type Parameters

### T

`T`

## Properties

### useClass

> `readonly` **useClass**: [`CtorNoDeps`](CtorNoDeps.md)\<`T`\>

Defined in: [types.ts:42](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L42)

---

## Type Alias: ClassProviderWithContainer\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: ClassProviderWithContainer\<T\>

> **ClassProviderWithContainer**\<`T`\> = `object`

Defined in: [types.ts:43](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L43)

## Type Parameters

### T

`T`

## Properties

### useClass

> `readonly` **useClass**: [`CtorWithContainer`](CtorWithContainer.md)\<`T`\>

Defined in: [types.ts:43](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L43)

---

## Type Alias: ClassProviderWithObject\<T, O\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: ClassProviderWithObject\<T, O\>

> **ClassProviderWithObject**\<`T`, `O`\> = `object`

Defined in: [types.ts:48](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L48)

## Type Parameters

### T

`T`

### O

`O` *extends* `Record`\<`string`, `unknown`\>

## Properties

### inject

> `readonly` **inject**: [`InjectObject`](InjectObject.md)\<`O`\>

Defined in: [types.ts:51](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L51)

***

### useClass()

> `readonly` **useClass**: (`deps`) => `T`

Defined in: [types.ts:49](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L49)

#### Parameters

##### deps

`O`

#### Returns

`T`

---

## Type Alias: ClassProviderWithTuple\<T, A\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: ClassProviderWithTuple\<T, A\>

> **ClassProviderWithTuple**\<`T`, `A`\> = `object`

Defined in: [types.ts:44](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L44)

## Type Parameters

### T

`T`

### A

`A` *extends* readonly `unknown`[]

## Properties

### inject

> `readonly` **inject**: [`InjectTuple`](InjectTuple.md)\<`A`\>

Defined in: [types.ts:46](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L46)

***

### useClass()

> `readonly` **useClass**: (...`args`) => `T`

Defined in: [types.ts:45](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L45)

#### Parameters

##### args

...`A`

#### Returns

`T`

---

## Type Alias: ContainerGetter()

[**@orkestrel/core**](../index.md)

***

# Type Alias: ContainerGetter()

> **ContainerGetter** = [`Container`](../classes/Container.md)

Defined in: [types.ts:253](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L253)

> **ContainerGetter**(`name?`): [`Container`](../classes/Container.md)

Defined in: [types.ts:254](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L254)

## Parameters

### name?

`string` | `symbol`

## Returns

[`Container`](../classes/Container.md)

## Methods

### clear()

> **clear**(`name`, `force?`): `boolean`

Defined in: [types.ts:256](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L256)

#### Parameters

##### name

`string` | `symbol`

##### force?

`boolean`

#### Returns

`boolean`

***

### get()

#### Call Signature

> **get**\<`T`\>(`token`, `name?`): `undefined` \| `T`

Defined in: [types.ts:262](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L262)

##### Type Parameters

###### T

`T`

##### Parameters

###### token

[`Token`](Token.md)\<`T`\>

###### name?

`string` | `symbol`

##### Returns

`undefined` \| `T`

#### Call Signature

> **get**\<`TMap`\>(`tokens`, `name?`): \{ \[K in string \| number \| symbol\]: TMap\[K\] extends Token\<U\> ? undefined \| U : never \}

Defined in: [types.ts:263](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L263)

##### Type Parameters

###### TMap

`TMap` *extends* [`TokenRecord`](TokenRecord.md)

##### Parameters

###### tokens

`TMap`

###### name?

`string` | `symbol`

##### Returns

\{ \[K in string \| number \| symbol\]: TMap\[K\] extends Token\<U\> ? undefined \| U : never \}

#### Call Signature

> **get**\<`O`\>(`tokens`, `name?`): \{ \[K in string \| number \| symbol\]: undefined \| O\[K\] \}

Defined in: [types.ts:264](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L264)

##### Type Parameters

###### O

`O` *extends* `Record`\<`string`, `unknown`\>

##### Parameters

###### tokens

[`InjectObject`](InjectObject.md)\<`O`\>

###### name?

`string` | `symbol`

##### Returns

\{ \[K in string \| number \| symbol\]: undefined \| O\[K\] \}

#### Call Signature

> **get**\<`A`\>(`tokens`, `name?`): \{ \[K in string \| number \| symbol\]: undefined \| A\[K\<K\>\] \}

Defined in: [types.ts:265](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L265)

##### Type Parameters

###### A

`A` *extends* readonly `unknown`[]

##### Parameters

###### tokens

[`InjectTuple`](InjectTuple.md)\<`A`\>

###### name?

`string` | `symbol`

##### Returns

\{ \[K in string \| number \| symbol\]: undefined \| A\[K\<K\>\] \}

***

### list()

> **list**(): (`string` \| `symbol`)[]

Defined in: [types.ts:257](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L257)

#### Returns

(`string` \| `symbol`)[]

***

### resolve()

#### Call Signature

> **resolve**\<`T`\>(`token`, `name?`): `T`

Defined in: [types.ts:258](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L258)

##### Type Parameters

###### T

`T`

##### Parameters

###### token

[`Token`](Token.md)\<`T`\>

###### name?

`string` | `symbol`

##### Returns

`T`

#### Call Signature

> **resolve**\<`TMap`\>(`tokens`, `name?`): \{ \[K in string \| number \| symbol\]: TMap\[K\] extends Token\<U\> ? U : never \}

Defined in: [types.ts:259](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L259)

##### Type Parameters

###### TMap

`TMap` *extends* [`TokenRecord`](TokenRecord.md)

##### Parameters

###### tokens

`TMap`

###### name?

`string` | `symbol`

##### Returns

\{ \[K in string \| number \| symbol\]: TMap\[K\] extends Token\<U\> ? U : never \}

#### Call Signature

> **resolve**\<`O`\>(`tokens`, `name?`): `O`

Defined in: [types.ts:260](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L260)

##### Type Parameters

###### O

`O` *extends* `Record`\<`string`, `unknown`\>

##### Parameters

###### tokens

[`InjectObject`](InjectObject.md)\<`O`\>

###### name?

`string` | `symbol`

##### Returns

`O`

#### Call Signature

> **resolve**\<`A`\>(`tokens`, `name?`): `A`

Defined in: [types.ts:261](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L261)

##### Type Parameters

###### A

`A` *extends* readonly `unknown`[]

##### Parameters

###### tokens

[`InjectTuple`](InjectTuple.md)\<`A`\>

###### name?

`string` | `symbol`

##### Returns

`A`

***

### set()

> **set**(`name`, `c`, `lock?`): `void`

Defined in: [types.ts:255](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L255)

#### Parameters

##### name

`string` | `symbol`

##### c

[`Container`](../classes/Container.md)

##### lock?

`boolean`

#### Returns

`void`

***

### using()

#### Call Signature

> **using**(`fn`, `name?`): `Promise`\<`void`\>

Defined in: [types.ts:266](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L266)

##### Parameters

###### fn

(`c`) => `void` \| `Promise`\<`void`\>

###### name?

`string` | `symbol`

##### Returns

`Promise`\<`void`\>

#### Call Signature

> **using**\<`T`\>(`fn`, `name?`): `Promise`\<`T`\>

Defined in: [types.ts:267](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L267)

##### Type Parameters

###### T

`T`

##### Parameters

###### fn

(`c`) => `T` \| `Promise`\<`T`\>

###### name?

`string` | `symbol`

##### Returns

`Promise`\<`T`\>

#### Call Signature

> **using**\<`T`\>(`apply`, `fn`, `name?`): `Promise`\<`T`\>

Defined in: [types.ts:268](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L268)

##### Type Parameters

###### T

`T`

##### Parameters

###### apply

(`c`) => `void` \| `Promise`\<`void`\>

###### fn

(`c`) => `T` \| `Promise`\<`T`\>

###### name?

`string` | `symbol`

##### Returns

`Promise`\<`T`\>

---

## Type Alias: CtorNoDeps()\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: CtorNoDeps()\<T\>

> **CtorNoDeps**\<`T`\> = () => `T`

Defined in: [types.ts:39](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L39)

## Type Parameters

### T

`T`

## Returns

`T`

---

## Type Alias: CtorWithContainer()\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: CtorWithContainer()\<T\>

> **CtorWithContainer**\<`T`\> = (`container`) => `T`

Defined in: [types.ts:40](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L40)

## Type Parameters

### T

`T`

## Parameters

### container

[`Container`](../classes/Container.md)

## Returns

`T`

---

## Type Alias: DestroyJobResult

[**@orkestrel/core**](../index.md)

***

# Type Alias: DestroyJobResult

> **DestroyJobResult** = `Readonly`\<\{ `destroyOutcome?`: [`Outcome`](Outcome.md); `errors?`: [`LifecycleErrorDetail`](../interfaces/LifecycleErrorDetail.md)[]; `stopOutcome?`: [`Outcome`](Outcome.md); \}\>

Defined in: [types.ts:284](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L284)

---

## Type Alias: DiagnosticScope

[**@orkestrel/core**](../index.md)

***

# Type Alias: DiagnosticScope

> **DiagnosticScope** = `"lifecycle"` \| `"orchestrator"` \| `"container"` \| `"registry"` \| `"internal"`

Defined in: [types.ts:114](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L114)

---

## Type Alias: EmitterListener()\<EMap, E\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: EmitterListener()\<EMap, E\>

> **EmitterListener**\<`EMap`, `E`\> = (...`args`) => `void`

Defined in: [types.ts:162](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L162)

## Type Parameters

### EMap

`EMap` *extends* [`EventMap`](EventMap.md)

### E

`E` *extends* keyof `EMap` & `string`

## Parameters

### args

...`EMap`\[`E`\]

## Returns

`void`

---

## Type Alias: EventHandler()\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: EventHandler()\<T\>

> **EventHandler**\<`T`\> = (`payload`) => `void` \| `Promise`\<`void`\>

Defined in: [types.ts:173](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L173)

## Type Parameters

### T

`T`

## Parameters

### payload

`T`

## Returns

`void` \| `Promise`\<`void`\>

---

## Type Alias: EventMap

[**@orkestrel/core**](../index.md)

***

# Type Alias: EventMap

> **EventMap** = `Record`\<`string`, `unknown`[]\>

Defined in: [types.ts:161](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L161)

---

## Type Alias: FactoryProvider\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: FactoryProvider\<T\>

> **FactoryProvider**\<`T`\> = [`FactoryProviderNoDeps`](FactoryProviderNoDeps.md)\<`T`\> \| [`FactoryProviderWithContainer`](FactoryProviderWithContainer.md)\<`T`\> \| [`FactoryProviderWithTuple`](FactoryProviderWithTuple.md)\<`T`, readonly `unknown`[]\> \| [`FactoryProviderWithObject`](FactoryProviderWithObject.md)\<`T`, `Record`\<`string`, `unknown`\>\>

Defined in: [types.ts:33](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L33)

## Type Parameters

### T

`T`

---

## Type Alias: FactoryProviderNoDeps\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: FactoryProviderNoDeps\<T\>

> **FactoryProviderNoDeps**\<`T`\> = `object`

Defined in: [types.ts:22](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L22)

## Type Parameters

### T

`T`

## Properties

### useFactory()

> `readonly` **useFactory**: () => `T`

Defined in: [types.ts:22](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L22)

#### Returns

`T`

---

## Type Alias: FactoryProviderWithContainer\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: FactoryProviderWithContainer\<T\>

> **FactoryProviderWithContainer**\<`T`\> = `object`

Defined in: [types.ts:23](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L23)

## Type Parameters

### T

`T`

## Properties

### useFactory()

> `readonly` **useFactory**: (`container`) => `T`

Defined in: [types.ts:23](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L23)

#### Parameters

##### container

[`Container`](../classes/Container.md)

#### Returns

`T`

---

## Type Alias: FactoryProviderWithObject\<T, O\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: FactoryProviderWithObject\<T, O\>

> **FactoryProviderWithObject**\<`T`, `O`\> = `object`

Defined in: [types.ts:28](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L28)

## Type Parameters

### T

`T`

### O

`O` *extends* `Record`\<`string`, `unknown`\>

## Properties

### inject

> `readonly` **inject**: [`InjectObject`](InjectObject.md)\<`O`\>

Defined in: [types.ts:31](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L31)

***

### useFactory()

> `readonly` **useFactory**: (`deps`) => `T`

Defined in: [types.ts:29](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L29)

#### Parameters

##### deps

`O`

#### Returns

`T`

---

## Type Alias: FactoryProviderWithTuple\<T, A\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: FactoryProviderWithTuple\<T, A\>

> **FactoryProviderWithTuple**\<`T`, `A`\> = `object`

Defined in: [types.ts:24](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L24)

## Type Parameters

### T

`T`

### A

`A` *extends* readonly `unknown`[]

## Properties

### inject

> `readonly` **inject**: [`InjectTuple`](InjectTuple.md)\<`A`\>

Defined in: [types.ts:26](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L26)

***

### useFactory()

> `readonly` **useFactory**: (...`args`) => `T`

Defined in: [types.ts:25](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L25)

#### Parameters

##### args

...`A`

#### Returns

`T`

---

## Type Alias: FromSchema\<S\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: FromSchema\<S\>

> **FromSchema**\<`S`\> = `{ [K in keyof S]: ResolveRule<S[K]> }`

Defined in: [types.ts:103](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L103)

## Type Parameters

### S

`S` *extends* [`SchemaSpec`](SchemaSpec.md)

---

## Type Alias: Guard()\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: Guard()\<T\>

> **Guard**\<`T`\> = (`x`) => `x is T`

Defined in: [types.ts:89](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L89)

## Type Parameters

### T

`T`

## Parameters

### x

`unknown`

## Returns

`x is T`

---

## Type Alias: InjectObject\<O\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: InjectObject\<O\>

> **InjectObject**\<`O`\> = `Readonly`\<`{ [K in keyof O]: Token<O[K]> }`\>

Defined in: [types.ts:17](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L17)

## Type Parameters

### O

`O` *extends* `Record`\<`string`, `unknown`\>

---

## Type Alias: InjectTuple\<A\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: InjectTuple\<A\>

> **InjectTuple**\<`A`\> = `{ readonly [K in keyof A]: Token<A[K]> }`

Defined in: [types.ts:16](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L16)

## Type Parameters

### A

`A` *extends* readonly `unknown`[]

---

## Type Alias: LifecycleContext

[**@orkestrel/core**](../index.md)

***

# Type Alias: LifecycleContext

> **LifecycleContext** = `"normal"` \| `"rollback"` \| `"container"`

Defined in: [types.ts:118](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L118)

---

## Type Alias: LifecycleEventMap

[**@orkestrel/core**](../index.md)

***

# Type Alias: LifecycleEventMap

> **LifecycleEventMap** = `object`

Defined in: [types.ts:227](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L227)

## Properties

### create

> **create**: \[\]

Defined in: [types.ts:229](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L229)

***

### destroy

> **destroy**: \[\]

Defined in: [types.ts:232](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L232)

***

### error

> **error**: \[`Error`\]

Defined in: [types.ts:233](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L233)

***

### start

> **start**: \[\]

Defined in: [types.ts:230](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L230)

***

### stop

> **stop**: \[\]

Defined in: [types.ts:231](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L231)

***

### transition

> **transition**: \[[`LifecycleState`](LifecycleState.md)\]

Defined in: [types.ts:228](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L228)

---

## Type Alias: LifecycleHook

[**@orkestrel/core**](../index.md)

***

# Type Alias: LifecycleHook

> **LifecycleHook** = `"create"` \| `"start"` \| `"stop"` \| `"destroy"`

Defined in: [types.ts:117](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L117)

---

## Type Alias: LifecyclePhase

[**@orkestrel/core**](../index.md)

***

# Type Alias: LifecyclePhase

> **LifecyclePhase** = `"start"` \| `"stop"` \| `"destroy"`

Defined in: [types.ts:116](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L116)

---

## Type Alias: LifecycleState

[**@orkestrel/core**](../index.md)

***

# Type Alias: LifecycleState

> **LifecycleState** = `"created"` \| `"started"` \| `"stopped"` \| `"destroyed"`

Defined in: [types.ts:225](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L225)

---

## Type Alias: LogLevel

[**@orkestrel/core**](../index.md)

***

# Type Alias: LogLevel

> **LogLevel** = `"debug"` \| `"info"` \| `"warn"` \| `"error"`

Defined in: [types.ts:108](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L108)

---

## Type Alias: MessageMapEntry

[**@orkestrel/core**](../index.md)

***

# Type Alias: MessageMapEntry

> **MessageMapEntry** = `Readonly`\<\{ `level?`: [`LogLevel`](LogLevel.md); `message?`: `string`; \}\>

Defined in: [types.ts:152](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L152)

---

## Type Alias: OptionalResolvedMap\<TMap\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: OptionalResolvedMap\<TMap\>

> **OptionalResolvedMap**\<`TMap`\> = \{ \[K in keyof TMap\]: TMap\[K\] extends Token\<infer U\> ? U \| undefined : never \}

Defined in: [types.ts:12](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L12)

## Type Parameters

### TMap

`TMap` *extends* [`TokenRecord`](TokenRecord.md)

---

## Type Alias: OrchestratorGetter()

[**@orkestrel/core**](../index.md)

***

# Type Alias: OrchestratorGetter()

> **OrchestratorGetter** = [`Orchestrator`](../classes/Orchestrator.md)

Defined in: [types.ts:313](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L313)

> **OrchestratorGetter**(`name?`): [`Orchestrator`](../classes/Orchestrator.md)

Defined in: [types.ts:314](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L314)

## Parameters

### name?

`string` | `symbol`

## Returns

[`Orchestrator`](../classes/Orchestrator.md)

## Methods

### clear()

> **clear**(`name`, `force?`): `boolean`

Defined in: [types.ts:316](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L316)

#### Parameters

##### name

`string` | `symbol`

##### force?

`boolean`

#### Returns

`boolean`

***

### list()

> **list**(): (`string` \| `symbol`)[]

Defined in: [types.ts:317](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L317)

#### Returns

(`string` \| `symbol`)[]

***

### set()

> **set**(`name`, `o`, `lock?`): `void`

Defined in: [types.ts:315](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L315)

#### Parameters

##### name

`string` | `symbol`

##### o

[`Orchestrator`](../classes/Orchestrator.md)

##### lock?

`boolean`

#### Returns

`void`

---

## Type Alias: OrchestratorStartResult

[**@orkestrel/core**](../index.md)

***

# Type Alias: OrchestratorStartResult

> **OrchestratorStartResult** = `Readonly`\<\{ `lc`: [`Lifecycle`](../classes/Lifecycle.md); `result`: [`PhaseResult`](PhaseResult.md); `token`: [`Token`](Token.md)\<`unknown`\>; \}\>

Defined in: [types.ts:286](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L286)

---

## Type Alias: Outcome

[**@orkestrel/core**](../index.md)

***

# Type Alias: Outcome

> **Outcome** = `Readonly`\<\{ `durationMs`: `number`; `ok`: `boolean`; `timedOut?`: `boolean`; `token`: `string`; \}\>

Defined in: [types.ts:282](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L282)

---

## Type Alias: PhaseResult

[**@orkestrel/core**](../index.md)

***

# Type Alias: PhaseResult

> **PhaseResult** = [`PhaseResultOk`](PhaseResultOk.md) \| [`PhaseResultErr`](PhaseResultErr.md)

Defined in: [types.ts:280](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L280)

---

## Type Alias: PhaseResultErr

[**@orkestrel/core**](../index.md)

***

# Type Alias: PhaseResultErr

> **PhaseResultErr** = `Readonly`\<\{ `durationMs`: `number`; `error`: `Error`; `ok`: `false`; `timedOut`: `boolean`; \}\>

Defined in: [types.ts:279](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L279)

---

## Type Alias: PhaseResultOk

[**@orkestrel/core**](../index.md)

***

# Type Alias: PhaseResultOk

> **PhaseResultOk** = `Readonly`\<\{ `durationMs`: `number`; `ok`: `true`; \}\>

Defined in: [types.ts:278](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L278)

---

## Type Alias: PhaseTimeouts

[**@orkestrel/core**](../index.md)

***

# Type Alias: PhaseTimeouts

> **PhaseTimeouts** = `Readonly`\<\{ `onDestroy?`: `number`; `onStart?`: `number`; `onStop?`: `number`; \}\>

Defined in: [types.ts:274](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L274)

---

## Type Alias: PrimitiveTag

[**@orkestrel/core**](../index.md)

***

# Type Alias: PrimitiveTag

> **PrimitiveTag** = `"string"` \| `"number"` \| `"boolean"` \| `"symbol"` \| `"bigint"` \| `"function"` \| `"object"`

Defined in: [types.ts:90](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L90)

---

## Type Alias: Provider\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: Provider\<T\>

> **Provider**\<`T`\> = `T` \| [`ValueProvider`](../interfaces/ValueProvider.md)\<`T`\> \| [`FactoryProvider`](FactoryProvider.md)\<`T`\> \| [`ClassProvider`](ClassProvider.md)\<`T`\>

Defined in: [types.ts:55](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L55)

## Type Parameters

### T

`T`

---

## Type Alias: ProviderMatchHandlers\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: ProviderMatchHandlers\<T\>

> **ProviderMatchHandlers**\<`T`\> = `object`

Defined in: [types.ts:60](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L60)

## Type Parameters

### T

`T`

## Properties

### classContainer()

> **classContainer**: (`p`) => [`ClassProviderWithContainer`](ClassProviderWithContainer.md)\<`T`\>

Defined in: [types.ts:69](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L69)

#### Parameters

##### p

[`ClassProviderWithContainer`](ClassProviderWithContainer.md)\<`T`\>

#### Returns

[`ClassProviderWithContainer`](ClassProviderWithContainer.md)\<`T`\>

***

### classNoDeps()

> **classNoDeps**: (`p`) => [`ClassProviderNoDeps`](ClassProviderNoDeps.md)\<`T`\>

Defined in: [types.ts:70](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L70)

#### Parameters

##### p

[`ClassProviderNoDeps`](ClassProviderNoDeps.md)\<`T`\>

#### Returns

[`ClassProviderNoDeps`](ClassProviderNoDeps.md)\<`T`\>

***

### classObject()

> **classObject**: \<`O`\>(`p`) => [`ClassProviderWithObject`](ClassProviderWithObject.md)\<`T`, `O`\>

Defined in: [types.ts:68](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L68)

#### Type Parameters

##### O

`O` *extends* `Record`\<`string`, `unknown`\>

#### Parameters

##### p

[`ClassProviderWithObject`](ClassProviderWithObject.md)\<`T`, `O`\>

#### Returns

[`ClassProviderWithObject`](ClassProviderWithObject.md)\<`T`, `O`\>

***

### classTuple()

> **classTuple**: \<`A`\>(`p`) => [`ClassProviderWithTuple`](ClassProviderWithTuple.md)\<`T`, `A`\>

Defined in: [types.ts:67](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L67)

#### Type Parameters

##### A

`A` *extends* readonly `unknown`[]

#### Parameters

##### p

[`ClassProviderWithTuple`](ClassProviderWithTuple.md)\<`T`, `A`\>

#### Returns

[`ClassProviderWithTuple`](ClassProviderWithTuple.md)\<`T`, `A`\>

***

### factoryContainer()

> **factoryContainer**: (`p`) => [`FactoryProviderWithContainer`](FactoryProviderWithContainer.md)\<`T`\>

Defined in: [types.ts:65](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L65)

#### Parameters

##### p

[`FactoryProviderWithContainer`](FactoryProviderWithContainer.md)\<`T`\>

#### Returns

[`FactoryProviderWithContainer`](FactoryProviderWithContainer.md)\<`T`\>

***

### factoryNoDeps()

> **factoryNoDeps**: (`p`) => [`FactoryProviderNoDeps`](FactoryProviderNoDeps.md)\<`T`\>

Defined in: [types.ts:66](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L66)

#### Parameters

##### p

[`FactoryProviderNoDeps`](FactoryProviderNoDeps.md)\<`T`\>

#### Returns

[`FactoryProviderNoDeps`](FactoryProviderNoDeps.md)\<`T`\>

***

### factoryObject()

> **factoryObject**: \<`O`\>(`p`) => [`FactoryProviderWithObject`](FactoryProviderWithObject.md)\<`T`, `O`\>

Defined in: [types.ts:64](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L64)

#### Type Parameters

##### O

`O` *extends* `Record`\<`string`, `unknown`\>

#### Parameters

##### p

[`FactoryProviderWithObject`](FactoryProviderWithObject.md)\<`T`, `O`\>

#### Returns

[`FactoryProviderWithObject`](FactoryProviderWithObject.md)\<`T`, `O`\>

***

### factoryTuple()

> **factoryTuple**: \<`A`\>(`p`) => [`FactoryProviderWithTuple`](FactoryProviderWithTuple.md)\<`T`, `A`\>

Defined in: [types.ts:63](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L63)

#### Type Parameters

##### A

`A` *extends* readonly `unknown`[]

#### Parameters

##### p

[`FactoryProviderWithTuple`](FactoryProviderWithTuple.md)\<`T`, `A`\>

#### Returns

[`FactoryProviderWithTuple`](FactoryProviderWithTuple.md)\<`T`, `A`\>

***

### raw()

> **raw**: (`value`) => [`Provider`](Provider.md)\<`T`\>

Defined in: [types.ts:61](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L61)

#### Parameters

##### value

`T`

#### Returns

[`Provider`](Provider.md)\<`T`\>

***

### value()

> **value**: (`p`) => [`Provider`](Provider.md)\<`T`\>

Defined in: [types.ts:62](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L62)

#### Parameters

##### p

[`ValueProvider`](../interfaces/ValueProvider.md)\<`T`\>

#### Returns

[`Provider`](Provider.md)\<`T`\>

---

## Type Alias: ProviderMatchReturnHandlers\<T, R\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: ProviderMatchReturnHandlers\<T, R\>

> **ProviderMatchReturnHandlers**\<`T`, `R`\> = `object`

Defined in: [types.ts:73](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L73)

## Type Parameters

### T

`T`

### R

`R`

## Properties

### classContainer()

> **classContainer**: (`p`) => `R`

Defined in: [types.ts:82](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L82)

#### Parameters

##### p

[`ClassProviderWithContainer`](ClassProviderWithContainer.md)\<`T`\>

#### Returns

`R`

***

### classNoDeps()

> **classNoDeps**: (`p`) => `R`

Defined in: [types.ts:83](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L83)

#### Parameters

##### p

[`ClassProviderNoDeps`](ClassProviderNoDeps.md)\<`T`\>

#### Returns

`R`

***

### classObject()

> **classObject**: \<`O`\>(`p`) => `R`

Defined in: [types.ts:81](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L81)

#### Type Parameters

##### O

`O` *extends* `Record`\<`string`, `unknown`\>

#### Parameters

##### p

[`ClassProviderWithObject`](ClassProviderWithObject.md)\<`T`, `O`\>

#### Returns

`R`

***

### classTuple()

> **classTuple**: \<`A`\>(`p`) => `R`

Defined in: [types.ts:80](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L80)

#### Type Parameters

##### A

`A` *extends* readonly `unknown`[]

#### Parameters

##### p

[`ClassProviderWithTuple`](ClassProviderWithTuple.md)\<`T`, `A`\>

#### Returns

`R`

***

### factoryContainer()

> **factoryContainer**: (`p`) => `R`

Defined in: [types.ts:78](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L78)

#### Parameters

##### p

[`FactoryProviderWithContainer`](FactoryProviderWithContainer.md)\<`T`\>

#### Returns

`R`

***

### factoryNoDeps()

> **factoryNoDeps**: (`p`) => `R`

Defined in: [types.ts:79](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L79)

#### Parameters

##### p

[`FactoryProviderNoDeps`](FactoryProviderNoDeps.md)\<`T`\>

#### Returns

`R`

***

### factoryObject()

> **factoryObject**: \<`O`\>(`p`) => `R`

Defined in: [types.ts:77](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L77)

#### Type Parameters

##### O

`O` *extends* `Record`\<`string`, `unknown`\>

#### Parameters

##### p

[`FactoryProviderWithObject`](FactoryProviderWithObject.md)\<`T`, `O`\>

#### Returns

`R`

***

### factoryTuple()

> **factoryTuple**: \<`A`\>(`p`) => `R`

Defined in: [types.ts:76](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L76)

#### Type Parameters

##### A

`A` *extends* readonly `unknown`[]

#### Parameters

##### p

[`FactoryProviderWithTuple`](FactoryProviderWithTuple.md)\<`T`, `A`\>

#### Returns

`R`

***

### raw()

> **raw**: (`value`) => `R`

Defined in: [types.ts:74](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L74)

#### Parameters

##### value

`T`

#### Returns

`R`

***

### value()

> **value**: (`p`) => `R`

Defined in: [types.ts:75](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L75)

#### Parameters

##### p

[`ValueProvider`](../interfaces/ValueProvider.md)\<`T`\>

#### Returns

`R`

---

## Type Alias: ResolvedMap\<TMap\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: ResolvedMap\<TMap\>

> **ResolvedMap**\<`TMap`\> = `{ [K in keyof TMap]: TMap[K] extends Token<infer U> ? U : never }`

Defined in: [types.ts:11](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L11)

## Type Parameters

### TMap

`TMap` *extends* [`TokenRecord`](TokenRecord.md)

---

## Type Alias: ResolveRule\<R\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: ResolveRule\<R\>

> **ResolveRule**\<`R`\> = `R` *extends* `"string"` ? `string` : `R` *extends* `"number"` ? `number` : `R` *extends* `"boolean"` ? `boolean` : `R` *extends* `"symbol"` ? `symbol` : `R` *extends* `"bigint"` ? `bigint` : `R` *extends* `"function"` ? (...`args`) => `unknown` : `R` *extends* `"object"` ? `Record`\<`string`, `unknown`\> : `R` *extends* [`Guard`](Guard.md)\<infer U\> ? `U` : `R` *extends* [`SchemaSpec`](SchemaSpec.md) ? [`FromSchema`](FromSchema.md)\<`R`\> : `never`

Defined in: [types.ts:92](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L92)

## Type Parameters

### R

`R`

---

## Type Alias: SchemaSpec

[**@orkestrel/core**](../index.md)

***

# Type Alias: SchemaSpec

> **SchemaSpec** = `Readonly`\<\{\[`k`: `string`\]: `Readonly`\<\{\[`k`: `string`\]: Readonly\<\{ \[k: string\]: Readonly\<...\> \| PrimitiveTag \| Guard\<unknown\>; \}\> \| PrimitiveTag \| Guard\<unknown\>; \}\> \| [`PrimitiveTag`](PrimitiveTag.md) \| [`Guard`](Guard.md)\<`unknown`\>; \}\>

Defined in: [types.ts:91](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L91)

---

## Type Alias: Task()\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: Task()\<T\>

> **Task**\<`T`\> = () => `Promise`\<`T`\>

Defined in: [types.ts:276](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L276)

## Type Parameters

### T

`T`

## Returns

`Promise`\<`T`\>

---

## Type Alias: Token\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: Token\<T\>

> **Token**\<`T`\> = `symbol` & `object`

Defined in: [types.ts:8](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L8)

## Type Declaration

### \_\_t?

> `readonly` `optional` **\_\_t**: `T`

## Type Parameters

### T

`T`

---

## Type Alias: TokenRecord

[**@orkestrel/core**](../index.md)

***

# Type Alias: TokenRecord

> **TokenRecord** = `Record`\<`string`, [`Token`](Token.md)\<`unknown`\>\>

Defined in: [types.ts:10](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L10)

---

## Type Alias: TokensOf\<T\>

[**@orkestrel/core**](../index.md)

***

# Type Alias: TokensOf\<T\>

> **TokensOf**\<`T`\> = `{ [K in keyof T & string]: Token<T[K]> }`

Defined in: [types.ts:9](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/types.ts#L9)

## Type Parameters

### T

`T` *extends* `Record`\<`string`, `unknown`\>

---

## Variable: CONTAINER\_MESSAGES

[**@orkestrel/core**](../index.md)

***

# Variable: CONTAINER\_MESSAGES

> `const` **CONTAINER\_MESSAGES**: `ReadonlyArray`\<[`DiagnosticMessage`](../interfaces/DiagnosticMessage.md)\>

Defined in: [constants.ts:54](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/constants.ts#L54)

Container diagnostic messages and codes.

---

## Variable: container

[**@orkestrel/core**](../index.md)

***

# Variable: container

> `const` **container**: (`name?`) => [`Container`](../classes/Container.md) & `object`

Defined in: [container.ts:486](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/container.ts#L486)

Global container getter and manager.

## Type Declaration

### get()

> **get**: \{\<`T`\>(`token`, `name?`): `undefined` \| `T`; \<`A`\>(`tokens`, `name?`): \{ \[K in string \| number \| symbol\]: undefined \| A\[K\<K\>\] \}; \<`O`\>(`tokens`, `name?`): \{ \[K in string \| number \| symbol\]: undefined \| O\[K\] \}; \<`TMap`\>(`tokens`, `name?`): [`OptionalResolvedMap`](../type-aliases/OptionalResolvedMap.md)\<`TMap`\>; \} = `containerGet`

#### Call Signature

> \<`T`\>(`token`, `name?`): `undefined` \| `T`

##### Type Parameters

###### T

`T`

##### Parameters

###### token

[`Token`](../type-aliases/Token.md)\<`T`\>

###### name?

`string` | `symbol`

##### Returns

`undefined` \| `T`

#### Call Signature

> \<`A`\>(`tokens`, `name?`): \{ \[K in string \| number \| symbol\]: undefined \| A\[K\<K\>\] \}

##### Type Parameters

###### A

`A` *extends* readonly `unknown`[]

##### Parameters

###### tokens

[`InjectTuple`](../type-aliases/InjectTuple.md)\<`A`\>

###### name?

`string` | `symbol`

##### Returns

\{ \[K in string \| number \| symbol\]: undefined \| A\[K\<K\>\] \}

#### Call Signature

> \<`O`\>(`tokens`, `name?`): \{ \[K in string \| number \| symbol\]: undefined \| O\[K\] \}

##### Type Parameters

###### O

`O` *extends* `Record`\<`string`, `unknown`\>

##### Parameters

###### tokens

[`InjectObject`](../type-aliases/InjectObject.md)\<`O`\>

###### name?

`string` | `symbol`

##### Returns

\{ \[K in string \| number \| symbol\]: undefined \| O\[K\] \}

#### Call Signature

> \<`TMap`\>(`tokens`, `name?`): [`OptionalResolvedMap`](../type-aliases/OptionalResolvedMap.md)\<`TMap`\>

##### Type Parameters

###### TMap

`TMap` *extends* [`TokenRecord`](../type-aliases/TokenRecord.md)

##### Parameters

###### tokens

`TMap`

###### name?

`string` | `symbol`

##### Returns

[`OptionalResolvedMap`](../type-aliases/OptionalResolvedMap.md)\<`TMap`\>

### resolve()

> **resolve**: \{\<`T`\>(`token`, `name?`): `T`; \<`O`\>(`tokens`, `name?`): `O`; \<`A`\>(`tokens`, `name?`): `A`; \<`TMap`\>(`tokens`, `name?`): [`ResolvedMap`](../type-aliases/ResolvedMap.md)\<`TMap`\>; \} = `containerResolve`

#### Call Signature

> \<`T`\>(`token`, `name?`): `T`

##### Type Parameters

###### T

`T`

##### Parameters

###### token

[`Token`](../type-aliases/Token.md)\<`T`\>

###### name?

`string` | `symbol`

##### Returns

`T`

#### Call Signature

> \<`O`\>(`tokens`, `name?`): `O`

##### Type Parameters

###### O

`O` *extends* `Record`\<`string`, `unknown`\>

##### Parameters

###### tokens

[`InjectObject`](../type-aliases/InjectObject.md)\<`O`\>

###### name?

`string` | `symbol`

##### Returns

`O`

#### Call Signature

> \<`A`\>(`tokens`, `name?`): `A`

##### Type Parameters

###### A

`A` *extends* readonly `unknown`[]

##### Parameters

###### tokens

[`InjectTuple`](../type-aliases/InjectTuple.md)\<`A`\>

###### name?

`string` | `symbol`

##### Returns

`A`

#### Call Signature

> \<`TMap`\>(`tokens`, `name?`): [`ResolvedMap`](../type-aliases/ResolvedMap.md)\<`TMap`\>

##### Type Parameters

###### TMap

`TMap` *extends* [`TokenRecord`](../type-aliases/TokenRecord.md)

##### Parameters

###### tokens

`TMap`

###### name?

`string` | `symbol`

##### Returns

[`ResolvedMap`](../type-aliases/ResolvedMap.md)\<`TMap`\>

### using()

> **using**: \{(`fn`, `name?`): `Promise`\<`void`\>; \<`T`\>(`fn`, `name?`): `Promise`\<`T`\>; \<`T`\>(`apply`, `fn`, `name?`): `Promise`\<`T`\>; \} = `containerUsing`

#### Call Signature

> (`fn`, `name?`): `Promise`\<`void`\>

##### Parameters

###### fn

(`c`) => `void` \| `Promise`\<`void`\>

###### name?

`string` | `symbol`

##### Returns

`Promise`\<`void`\>

#### Call Signature

> \<`T`\>(`fn`, `name?`): `Promise`\<`T`\>

##### Type Parameters

###### T

`T`

##### Parameters

###### fn

(`c`) => `T` \| `Promise`\<`T`\>

###### name?

`string` | `symbol`

##### Returns

`Promise`\<`T`\>

#### Call Signature

> \<`T`\>(`apply`, `fn`, `name?`): `Promise`\<`T`\>

##### Type Parameters

###### T

`T`

##### Parameters

###### apply

(`c`) => `void` \| `Promise`\<`void`\>

###### fn

(`c`) => `T` \| `Promise`\<`T`\>

###### name?

`string` | `symbol`

##### Returns

`Promise`\<`T`\>

### clear()

> **clear**(`name?`, `force?`): `boolean`

#### Parameters

##### name?

`string` | `symbol`

##### force?

`boolean`

#### Returns

`boolean`

### list()

> **list**(): (`string` \| `symbol`)[]

#### Returns

(`string` \| `symbol`)[]

### set()

> **set**(`name`, `c`, `lock?`): `void`

#### Parameters

##### name

`string` | `symbol`

##### c

[`Container`](../classes/Container.md)

##### lock?

`boolean`

#### Returns

`void`

## Example

```ts
import { container, createToken } from '@orkestrel/core'

const A = createToken<number>('A')
container().set(A, 7)
const v = container.resolve(A) // 7

await container.using(async (scope) => {
  scope.set(A, 1)
  // scoped registration does not leak
})
```

---

## Variable: HELP

[**@orkestrel/core**](../index.md)

***

# Variable: HELP

> `const` **HELP**: `object`

Defined in: [constants.ts:90](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/constants.ts#L90)

Links to documentation sections used in error messages for help.
Consumers may display these URLs when rendering errors.

## Type Declaration

### container

> `readonly` **container**: `"https://github.com/orkestrel/core/blob/main/api/index.html#container"` = `'https://github.com/orkestrel/core/blob/main/api/index.html#container'`

### errors

> `readonly` **errors**: `"https://github.com/orkestrel/core/blob/main/api/index.html#troubleshooting"` = `'https://github.com/orkestrel/core/blob/main/api/index.html#troubleshooting'`

### lifecycle

> `readonly` **lifecycle**: `"https://github.com/orkestrel/core/blob/main/api/index.html#lifecycle"` = `'https://github.com/orkestrel/core/blob/main/api/index.html#lifecycle'`

### orchestrator

> `readonly` **orchestrator**: `"https://github.com/orkestrel/core/blob/main/api/index.html#orchestrator"` = `'https://github.com/orkestrel/core/blob/main/api/index.html#orchestrator'`

### providers

> `readonly` **providers**: `"https://github.com/orkestrel/core/blob/main/api/index.html#register-and-resolve"` = `'https://github.com/orkestrel/core/blob/main/api/index.html#register-and-resolve'`

### registry

> `readonly` **registry**: `"https://github.com/orkestrel/core/blob/main/api/index.html#registry"` = `'https://github.com/orkestrel/core/blob/main/api/index.html#registry'`

---

## Variable: INTERNAL\_MESSAGES

[**@orkestrel/core**](../index.md)

***

# Variable: INTERNAL\_MESSAGES

> `const` **INTERNAL\_MESSAGES**: `ReadonlyArray`\<[`DiagnosticMessage`](../interfaces/DiagnosticMessage.md)\>

Defined in: [constants.ts:82](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/constants.ts#L82)

Internal invariant diagnostic codes.

---

## Variable: LIFECYCLE\_MESSAGES

[**@orkestrel/core**](../index.md)

***

# Variable: LIFECYCLE\_MESSAGES

> `const` **LIFECYCLE\_MESSAGES**: `ReadonlyArray`\<[`DiagnosticMessage`](../interfaces/DiagnosticMessage.md)\>

Defined in: [constants.ts:26](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/constants.ts#L26)

Default lifecycle diagnostic messages and codes used by Lifecycle/Queue.

---

## Variable: ORCHESTRATOR\_MESSAGES

[**@orkestrel/core**](../index.md)

***

# Variable: ORCHESTRATOR\_MESSAGES

> `const` **ORCHESTRATOR\_MESSAGES**: `ReadonlyArray`\<[`DiagnosticMessage`](../interfaces/DiagnosticMessage.md)\>

Defined in: [constants.ts:35](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/constants.ts#L35)

Orchestrator diagnostic messages and codes.

---

## Variable: orchestrator

[**@orkestrel/core**](../index.md)

***

# Variable: orchestrator

> `const` **orchestrator**: (`name?`) => [`Orchestrator`](../classes/Orchestrator.md) & `object`

Defined in: [orchestrator.ts:569](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/orchestrator.ts#L569)

Global orchestrator getter.
- Returns the default or a named orchestrator instance bound to a container.
- Manage instances via set/clear/list; use using() to run scoped work.

## Type Declaration

### using()

> **using**: \{(`fn`, `name?`): `Promise`\<`void`\>; \<`T`\>(`fn`, `name?`): `Promise`\<`T`\>; \<`T`\>(`apply`, `fn`, `name?`): `Promise`\<`T`\>; \} = `orchestratorUsing`

#### Call Signature

> (`fn`, `name?`): `Promise`\<`void`\>

##### Parameters

###### fn

(`app`) => `void` \| `Promise`\<`void`\>

###### name?

`string` | `symbol`

##### Returns

`Promise`\<`void`\>

#### Call Signature

> \<`T`\>(`fn`, `name?`): `Promise`\<`T`\>

##### Type Parameters

###### T

`T`

##### Parameters

###### fn

(`app`) => `T` \| `Promise`\<`T`\>

###### name?

`string` | `symbol`

##### Returns

`Promise`\<`T`\>

#### Call Signature

> \<`T`\>(`apply`, `fn`, `name?`): `Promise`\<`T`\>

##### Type Parameters

###### T

`T`

##### Parameters

###### apply

(`app`) => `void` \| `Promise`\<`void`\>

###### fn

(`app`) => `T` \| `Promise`\<`T`\>

###### name?

`string` | `symbol`

##### Returns

`Promise`\<`T`\>

### clear()

> **clear**(`name?`, `force?`): `boolean`

#### Parameters

##### name?

`string` | `symbol`

##### force?

`boolean`

#### Returns

`boolean`

### list()

> **list**(): (`string` \| `symbol`)[]

#### Returns

(`string` \| `symbol`)[]

### set()

> **set**(`name`, `app`, `lock?`): `void`

#### Parameters

##### name

`string` | `symbol`

##### app

[`Orchestrator`](../classes/Orchestrator.md)

##### lock?

`boolean`

#### Returns

`void`

## Example

```ts
import { orchestrator, createToken, register, Container } from '@orkestrel/core'

const app = orchestrator()
const T = createToken<number>('val')
await app.container.using(scope => scope.set(T, 7))
```

---

## Variable: PORTS\_MESSAGES

[**@orkestrel/core**](../index.md)

***

# Variable: PORTS\_MESSAGES

> `const` **PORTS\_MESSAGES**: `ReadonlyArray`\<[`DiagnosticMessage`](../interfaces/DiagnosticMessage.md)\>

Defined in: [constants.ts:69](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/constants.ts#L69)

Port helper diagnostics and codes.

---

## Variable: QUEUE\_MESSAGES

[**@orkestrel/core**](../index.md)

***

# Variable: QUEUE\_MESSAGES

> `const` **QUEUE\_MESSAGES**: `ReadonlyArray`\<[`DiagnosticMessage`](../interfaces/DiagnosticMessage.md)\>

Defined in: [constants.ts:74](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/constants.ts#L74)

Queue diagnostic messages and codes.

---

## Variable: REGISTRY\_MESSAGES

[**@orkestrel/core**](../index.md)

***

# Variable: REGISTRY\_MESSAGES

> `const` **REGISTRY\_MESSAGES**: `ReadonlyArray`\<[`DiagnosticMessage`](../interfaces/DiagnosticMessage.md)\>

Defined in: [constants.ts:61](https://github.com/orkestrel/core/blob/076093e61b67cd3d4198b173439f047ddbc97abc/src/constants.ts#L61)

Registry diagnostic messages and codes.

